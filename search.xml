<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[移动端 viewport 讲解]]></title>
      <url>/year/06/16/viewport%E7%9A%84%E6%A6%82%E5%BF%B5/</url>
      <content type="html"><![CDATA[<h4 id="一、viewport的概念"><a href="#一、viewport的概念" class="headerlink" title="一、viewport的概念"></a>一、viewport的概念</h4><p>说到移动端，不得不说到 <strong>视图</strong> 的概念，也就是<code>viewport</code>，移动设备上的<code>viewport</code>就是设备屏幕上能用来显示我们网页的那一块区域（不是整个屏幕哦~），具体来讲呢，就是浏览器上用来显示网页的那部分区域，但<code>viewport</code>又不限于浏览器的可视区域的大小，它可能比浏览器的可视区域还要大，也可能比浏览器的可是区域要小。<a id="more"></a>在默认情况下，移动设备上的<code>viewport</code>都是要大于浏览器可视区域的，这是因为考虑到移动设备的分辨率相对于桌面电脑来说都比较小，所以为了能在移动设备上正常显示那些传统的为桌面浏览器设计的网站，移动设备上的浏览器都会把自己默认的<code>viewport</code>设为<code>980px</code>或<code>1024px</code>（也可能是其它值，这个是由设备自己决定的），但带来的后果就是浏览器会出现横向滚动条，因为浏览器可视区域的宽度是比这个默认的<code>viewport</code>的宽度要小的。下图列出了一些设备上浏览器的默认<code>viewport</code>的宽度。<br><img src="http://i4.piimg.com/594295/6971653a02bba224.png" alt="viewport"></p>
<p><center style="font-size:15px;">viewport<center></center></center></p>
<p><hr></p>
<h4 id="二、移动端-CSS-的像素问题"><a href="#二、移动端-CSS-的像素问题" class="headerlink" title="二、移动端 CSS 的像素问题"></a>二、移动端 <strong>CSS</strong> 的像素问题</h4><blockquote>
<p><strong>CSS</strong>中的<code>1px</code>并不等于设备的<code>1px</code></p>
</blockquote>
<p>在<strong>CSS</strong>中我们一般使用<code>px</code>作为单位，在桌面浏览器中<strong><strong>CSS</strong></strong>的1个像素往往都是对应着电脑屏幕的<code>1</code>个物理像素，这可能会造成我们的一个错觉，那就是<strong>CSS</strong>中的像素就是设备的物理像素。但实际情况却并非如此，<strong>CSS</strong>中的像素只是一个抽象的单位，在不同的设备或不同的环境中，<strong>CSS</strong>中的<code>1px</code>所代表的设备物理像素是不同的。在为桌面浏览器设计的网页中，我们无需对这个斤斤计较，但在移动设备上，必须弄明白这点。在早先的移动设备中，屏幕像素密度都比较低，如<code>iphone3</code>，它的分辨率为<code>320x480</code>，在<code>iphone3</code>上，一个<strong>CSS</strong>像素确实是等于一个屏幕物理像素的。后来随着技术的发展，移动设备的屏幕像素密度越来越高，从<code>iphone4</code>开始，苹果公司便推出了所谓的<code>Retina</code>屏，分辨率提高了一倍，变成<code>640x960</code>，但屏幕尺寸却没变化，这就意味着同样大小的屏幕上，像素却多了一倍，这时，一个<strong>CSS</strong>像素是等于两个物理像素的（这个地方有点绕，仔细理解一下，原本同样<code>分辨率</code>同样大小的的屏幕可以装这么多东西，现在<code>分辨率</code>大了，而屏幕大小不变，所以就可以装下比原来更多的东西）。其他品牌的移动设备也是这个道理。例如安卓设备根据屏幕像素密度可分为<code>ldpi</code>、<code>mdpi</code>、<code>hdpi</code>、<code>xhdpi</code>等不同的等级，分辨率也是五花八门，安卓设备上的一个<strong>CSS</strong>像素相当于多少个屏幕物理像素，也因设备的不同而不同，没有一个定论。</p>
<p>还有一个因素也会引起<strong>CSS</strong>中px的变化，那就是用户缩放。例如，当用户把页面放大一倍，那么<strong>CSS</strong>中1px所代表的物理像素也会增加一倍；反之把页面缩小一倍，<strong>CSS</strong>中1px所代表的物理像素也会减少一倍。关于这点，在文章后面的部分还会讲到。</p>
<p>在移动端浏览器中以及某些桌面浏览器中，window对象有一个<code>devicePixelRatio</code>属性，它的官方的定义为：设备物理像素和设备独立像素的比例，也就是 <code>devicePixelRatio = 物理像素 / 独立像素</code>。<strong>CSS</strong>中的px就可以看做是设备的独立像素，所以通过devicePixelRatio，我们可以知道该设备上一个<strong>CSS</strong>像素代表多少个物理像素。例如，在<code>Retina</code>屏的<code>iphone</code>上，<code>devicePixelRatio</code>的值为<code>2</code>，也就是说<code>1</code>个<strong>CSS</strong>像素相当于<code>2</code>个物理像素。但是要注意的是，<code>devicePixelRatio</code>在不同的浏览器中还存在些许的兼容性问题，所以我们现在还并不能完全信赖这个东西，具体的情况可以看下<a href="http://www.quirksmode.org/blog/archives/2012/06/devicepixelrati.html" target="_blank" rel="external">这篇文章</a>。<br>devicePixelRatio的测试结果：<br><img src="http://i4.piimg.com/594295/d9ec3e5b823d7100.png" alt="viewport测试结果"></p>
<p><center style="font-size:15px;">viewport测试结果<center></center></center></p>
<p><hr></p>
<h4 id="三、关于PPK大神的三个viewport的理论"><a href="#三、关于PPK大神的三个viewport的理论" class="headerlink" title="三、关于PPK大神的三个viewport的理论"></a>三、关于PPK大神的三个viewport的理论</h4><p>ppk大神对于移动设备上的viewport有着非常多的研究（<a href="http://www.quirksmode.org/mobile/viewports.html" target="_blank" rel="external">第一篇</a>，<a href="http://www.quirksmode.org/mobile/viewports2.html" target="_blank" rel="external">第二篇</a>，<a href="http://www.quirksmode.org/mobile/viewports3.html" target="_blank" rel="external">第三篇</a>），有兴趣的同学可以去看一下，本文中有很多数据和观点也是出自那里，也是目前网上关于<code>viewport</code>的讨论的论据。ppk认为，移动设备上有三个<code>viewport</code>。</p>
<h5 id="layout-viewport"><a href="#layout-viewport" class="headerlink" title="layout viewport"></a>layout viewport</h5><p>首先，移动设备上的浏览器认为自己必须能让所有的网站都正常显示，即使是那些不是为移动设备设计的网站。但如果以浏览器的可视区域作为<code>viewport</code>的话，因为移动设备的屏幕都不是很宽，所以那些为桌面浏览器设计的网站放到移动设备上显示时，必然会因为移动设备的<code>viewport</code>太窄，而挤作一团，甚至布局什么的都会乱掉。也许有人会问，现在不是有很多手机分辨率都非常大吗，比如<code>768x1024</code>，或者<code>1080x1920</code>这样，那这样的手机用来显示为桌面浏览器设计的网站是没问题的吧？前面我们已经说了，<strong>CSS</strong>中的<code>1px</code>并不是代表屏幕上的<code>1px</code>，你分辨率越大，<strong>CSS</strong>中<code>1px</code>代表的物理像素就会越多，<code>devicePixelRatio</code>的值也越大，这很好理解，因为你分辨率增大了，但屏幕尺寸并没有变大多少，必须让<strong>CSS</strong>中的<code>1px</code>代表更多的物理像素，才能让<code>1px</code>的东西在屏幕上的大小与那些低分辨率的设备差不多，不然就会因为太小而看不清。所以在<code>1080x1920</code>这样的设备上，在默认情况下，也许你只要把一个div的宽度设为<code>300多px</code>（视<code>devicePixelRatio</code>的值而定），就是满屏的宽度了。回到正题上来，如果把移动设备上浏览器的可视区域设为viewport的话，某些网站就会因为<code>viewport</code>太窄而显示错乱，所以这些浏览器就决定默认情况下把<code>viewport</code>设为一个较宽的值，比如<code>980px</code>，这样的话即使是那些为桌面设计的网站也能在移动浏览器上正常显示了。ppk把这个浏览器默认的<code>viewport</code>叫做 <code>layout viewport</code>。这个<code>layout viewport</code>的宽度可以通过 <code>document.documentElement.clientWidth</code> 来获取。<br><img src="http://i4.piimg.com/594295/e453c59d4c270d1e.png" alt="layout viewport"></p>
<h5 id="visual-viewport"><a href="#visual-viewport" class="headerlink" title="visual viewport"></a>visual viewport</h5><p>然而，<code>layout viewport</code> 的宽度是大于浏览器可视区域的宽度的，所以我们还需要一个<code>viewport</code>来代表浏览器可视区域的大小，ppk把这个viewport叫做 <code>visual viewport</code>。<code>visual viewport</code>的宽度可以通过 <code>window.innerWidth</code> 来获取。<br><img src="http://i4.piimg.com/594295/72fde53fe6cf98ad.png" alt="layout viewport"></p>
<h5 id="visual-viewport-1"><a href="#visual-viewport-1" class="headerlink" title="visual viewport"></a>visual viewport</h5><p>现在我们已经有两个<code>viewport</code>了：<code>layout viewport</code> 和 <code>visual viewport</code>。但浏览器觉得还不够，因为现在越来越多的网站都会为移动设备进行单独的设计，所以必须还要有一个能完美适配移动设备的<code>viewport</code>。所谓的完美适配指的是，首先不需要用户缩放和横向滚动条就能正常的查看网站的所有内容；第二，显示的文字的大小是合适，比如一段<code>14px</code>大小的文字，不会因为在一个高密度像素的屏幕里显示得太小而无法看清，理想的情况是这段<code>14px</code>的文字无论是在何种密度屏幕，何种分辨率下，显示出来的大小都是差不多的。当然，不只是文字，其他元素像图片什么的也是这个道理。ppk把这个<code>viewport</code>叫做 <code>ideal viewport</code>，也就是第三个<code>viewport</code>——移动设备的理想<code>viewport</code>。</p>
<p><code>ideal viewport</code>并没有一个固定的尺寸，不同的设备拥有有不同的<code>ideal viewport</code>。所有的<code>iphone</code>的<code>ideal viewport</code>宽度都是<code>320px</code>，无论它的屏幕宽度是<code>320</code>还是<code>640</code>，也就是说，在<code>iphone</code>中，<strong>CSS</strong>中的<code>320px</code>就代表<code>iphone</code>屏幕的宽度。</p>
<p>但是安卓设备就比较复杂了，有<code>320px</code>的，有<code>360px</code>的，有<code>384px</code>的等等，关于不同的设备<code>ideal viewport</code>的宽度都为多少，可以到去<a href="http://viewportsizes.com" target="_blank" rel="external">查看一下</a>，里面收集了众多设备的理想宽度。</p>
<blockquote>
<p>最后总结一下：<em>ppk</em>把移动设备上的<code>viewport</code>分为 <code>layout viewport</code> 、 <code>visual viewport</code> 和 <code>ideal viewport</code> 三类，其中的<code>ideal viewport</code>是最适合移动设备的<code>viewport</code>，<code>ideal viewport</code>的宽度等于移动设备的屏幕宽度，只要在css中把某一元素的宽度设为<code>ideal viewport</code>的宽度(单位用<code>px</code>)，那么这个元素的宽度就是设备屏幕的宽度了，也就是宽度为<code>100%</code>的效果。<code>ideal viewport</code> 的意义在于，无论在何种分辨率的屏幕下，那些针对<code>ideal viewport</code> 而设计的网站，不需要用户手动缩放，也不需要出现横向滚动条，都可以完美的呈现给用户。如果大家想对<code>viewport</code>深入了解，还是建议大家仔细阅读以下<em>ppk</em>的原文。</p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> viewport，移动端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Gulp API 讲解]]></title>
      <url>/year/06/15/Gulp%20API%20%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>很早之前学习<strong>Gulp</strong>的时候就说，要写一个<strong>Gulp</strong>的<code>API</code>讲解，后来把这事忘了，现在用<strong>Gulp</strong>也比较少，但是我欠大家的还是要做到的，好了不多说了，我知道你的时间也有限，那我们开始吧。<br><a id="more"></a></p>
<h4 id="gulp-src-globs-options"><a href="#gulp-src-globs-options" class="headerlink" title="gulp.src(globs[, options])"></a>gulp.src(globs[, options])</h4><blockquote>
<p>说明：src方法是指定需要处理的源文件的路径，gulp借鉴了Unix操作系统的管道（pipe）思想（<strong>Unix操作系统的管道（pipe）思想，前一级的输出，直接变成后一级的输入。通常命令和命令之间的衔接就是用pipe。类似jQuery的链式编程。</strong>）。前一级的输出，直接变成后一级的输入，gulp.src返回当前文件流至可用插件；</p>
</blockquote>
<ul>
<li><code>globs</code>：  需要处理的源文件匹配符路径，也就是找到自己要处理的文件。类型(必填)：<code>String or StringArray</code>；<br><strong>路径匹配示例：</strong><ul>
<li><code>“src/a.js”</code>：指定具体文件；</li>
<li><code>“*”</code>：匹配所有文件    例：src/*.js(包含src下的所有js文件)；</li>
<li><code>“**”</code>：匹配0个或多个子文件夹    例：<code>src/**/*.js</code>(包含    <code>src</code>的0个或多个子文件夹下的js文件)；</li>
<li><code>“{}”</code>：匹配多个属性    例：<code>src/{a,b}.js</code>(包含<code>a.js</code>和<code>b.js</code>文件)  <code>src/*.</code></li>
<li><code>{jpg,png,gif}</code>(<code>src</code>下的所有<code>jpg/png/gif</code>文件)；</li>
<li><code>“!”</code>：排除文件    例：<code>!src/a.js</code>(不包含<code>src</code>下的<code>a.js</code>文件)；</li>
</ul>
</li>
</ul>
<p><strong>源代码示例</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>),</div><div class="line">    sass = <span class="built_in">require</span>(<span class="string">'gulp-sass'</span>);</div><div class="line"> </div><div class="line">gulp.task(<span class="string">'testsass'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">//gulp.src('sass/test/style.sass')</span></div><div class="line">    gulp.src([<span class="string">'sass/**/*.sass'</span>,<span class="string">'!sass/&#123;extend,page&#125;/*.sass'</span>])</div><div class="line">        .pipe(sass())</div><div class="line">        .pipe(gulp.dest(<span class="string">'./css'</span>));</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<ul>
<li><code>options</code>：  类型(可选)：<code>Object</code>，有3个属性<code>buffer</code>、<code>read</code>、<code>base</code>；<ul>
<li><code>options.buffer</code>：  类型：<code>Boolean</code>  默认：<code>true</code> 设置为<code>false</code>，将返回<code>file.content</code>的流并且不缓冲文件，处理大文件时非常有用；</li>
<li><code>options.read</code>：  类型：<code>Boolean</code>  默认：<code>true</code> 设置<code>false</code>，将不执行读取文件操作，返回<code>null</code>；</li>
<li><code>options.base</code>：  类型：<code>String</code>  设置输出路径以某个路径的某个组成部分为基础向后拼接，具体看下面示例：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">gulp.src(<span class="string">'client/js/**/*.js'</span>) </div><div class="line">  .pipe(minify())</div><div class="line">  .pipe(gulp.dest(<span class="string">'build'</span>));  <span class="comment">// Writes 'build/somedir/somefile.js'</span></div><div class="line"> </div><div class="line">gulp.src(<span class="string">'client/js/**/*.js'</span>, &#123; <span class="attr">base</span>: <span class="string">'client'</span> &#125;)</div><div class="line">  .pipe(minify())</div><div class="line">  .pipe(gulp.dest(<span class="string">'build'</span>));  <span class="comment">// Writes 'build/js/somedir/somefile.js'</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="gulp-dest-path-options"><a href="#gulp-dest-path-options" class="headerlink" title="gulp.dest(path[, options])"></a>gulp.dest(path[, options])</h4><blockquote>
<p>说明：dest方法是指定处理完后文件输出的路径。就是把文件处理完成后放在哪里；<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">gulp.src(<span class="string">'./client/templates/*.jade'</span>)</div><div class="line">  .pipe(jade())</div><div class="line">  .pipe(gulp.dest(<span class="string">'./build/templates'</span>))</div><div class="line">  .pipe(minify())</div><div class="line">  .pipe(gulp.dest(<span class="string">'./build/minified_templates'</span>));</div></pre></td></tr></table></figure></p>
</blockquote>
<ul>
<li><code>path</code>：  类型(必填)：<code>String or Function</code> 指定文件输出路径，或者定义函数返回文件输出路径亦可；</li>
<li><code>options</code>：  类型(可选)：<code>Object</code>，有2个属性<code>cwd</code>、<code>mode</code>；<ul>
<li><code>options.cwd</code>：  类型：<code>String</code>  默认：<code>process.cwd()</code>：前脚本的工作目录的路径 当文件输出路径为相对路径将会用到；</li>
<li><code>options.mode</code>：  类型：<code>String</code>  默认：<code>0777</code> （最高权限）指定被创建文件夹的权限；<h4 id="gulp-task-name-deps-fn"><a href="#gulp-task-name-deps-fn" class="headerlink" title="gulp.task(name[, deps], fn)"></a>gulp.task(name[, deps], fn)</h4><blockquote>
<p>说明：<code>task</code>定义一个<code>gulp</code>的任务，即告诉<code>gulp</code>你要干嘛；</p>
</blockquote>
</li>
</ul>
</li>
<li><code>name</code>：  类型(必填)：<code>String</code> 指定任务的名称（不应该有空格）；</li>
<li><p><code>deps</code>：  类型(可选)：<code>StringArray</code>，该任务依赖的任务（注意：被依赖的任务需要返回当前任务的事件流，请参看下面示例）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">gulp.task(<span class="string">'testsass'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> gulp.src([<span class="string">'sass/style.sass'</span>])</div><div class="line">        .pipe(sass())</div><div class="line">        .pipe(gulp.dest(<span class="string">'./css'</span>));</div><div class="line">&#125;);</div><div class="line"> </div><div class="line">gulp.task(<span class="string">'minicss'</span>, [<span class="string">'testsass'</span>], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">//执行完testsass任务后再执行minicss任务</span></div><div class="line">    gulp.src([<span class="string">'css/*.css'</span>])</div><div class="line">        .pipe(minifyCss())</div><div class="line">        .pipe(gulp.dest(<span class="string">'./dist/css'</span>));</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p><code>fn</code>：  类型(必填)：<code>Function</code> 该任务调用的插件操作；</p>
<h4 id="gulp-watch-glob-opts-tasks-or-gulp-watch-glob-opts-cb"><a href="#gulp-watch-glob-opts-tasks-or-gulp-watch-glob-opts-cb" class="headerlink" title="gulp.watch(glob [, opts], tasks) or gulp.watch(glob [, opts, cb])"></a>gulp.watch(glob [, opts], tasks) or gulp.watch(glob [, opts, cb])</h4><blockquote>
<p>说明：watch方法是用于监听文件变化，文件一修改就会执行指定的任务；</p>
</blockquote>
</li>
<li><code>glob</code>：  需要处理的源文件匹配符路径。类型(必填)：<code>String or StringArray</code>；</li>
<li><code>opts</code>：  类型(可选)：<code>Object</code> 具体参看<a href="https://github.com/shama/gaze；" target="_blank" rel="external">https://github.com/shama/gaze；</a></li>
<li><code>tasks</code>：  类型(必填)：<code>StringArray</code> 需要执行的任务的名称数组；</li>
<li><code>cb(event)</code>：  类型(可选)：<code>Function</code> 每个文件变化执行的回调函数；<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">gulp.task(<span class="string">'watch1'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    gulp.watch(<span class="string">'sass/**/*.sass'</span>, [<span class="string">'testsass'</span>]);</div><div class="line">&#125;);</div><div class="line"> </div><div class="line">gulp.task(<span class="string">'watch2'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    gulp.watch(<span class="string">'js/**/*.js'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'File '</span> + event.path + <span class="string">' was '</span> + event.type + <span class="string">', running tasks...'</span>);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> Gulp，自动化 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[vue-router（二）：vue-router 2.0 的API变化]]></title>
      <url>/year/06/06/vue-router%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AAPI%20%E7%9A%84%E5%8F%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<p>vue-router 2.0 的变化</p>
<p>vue-router 2.0 相对1.0来说改动挺大，废弃了之前的标签写法，采用更加方便的写法。新<strong>API</strong>更符合<strong>Vue 2.0</strong>的思想。<br><a id="more"></a></p>
<h4 id="API-的变化"><a href="#API-的变化" class="headerlink" title="API 的变化"></a>API 的变化</h4><ul>
<li>由 <strong>vue-router 1.0</strong> 的<code>router.go()</code>改为<code>router.push()</code>，使用<code>router.push()</code>设置默认路由。</li>
<li>新的<code>router.go</code>类似<code>window.history.go()</code>：接受一个数值作为参数在历史栈中导航</li>
<li>新增的方法<ul>
<li>router.back()</li>
<li>router.forward()<h4 id="路由配置"><a href="#路由配置" class="headerlink" title="路由配置"></a>路由配置</h4></li>
</ul>
</li>
<li>所有路由配置都通过一个单独的对象传到Router的构造函数。</li>
<li>作废了一些配置项，修改了一些配置项，具体参考<a href="https://github.com/vuejs/vue-router/blob/43183911dedfbb30ebacccf2d76ced74d998448a/flow/declarations.js#L8-L16" target="_blank" rel="external">可用配置选项</a></li>
<li><code>routes</code> 选项取代了 <code>router.map()</code>。此外，路由配置现在用数组而不是用对象哈希表来作为数据结构。这保证了一致的匹配次序（对象键值枚举的次序是依赖浏览器的实现的）。<br><strong>以下的路由器实例配置选项被作废了：</strong></li>
<li><code>history</code>被<code>made</code>代替</li>
<li><code>abstrat</code>被<code>made</code>代替</li>
<li><code>root</code>被<code>base</code>代替</li>
<li><code>saveScrollPosition</code>被<code>scrollBehavior</code></li>
<li><code>hashbang</code>（因为<code>hashbang</code>在 Google 爬站的时候不在需要，所以移除）</li>
<li><code>transitionOnLoad</code> (因为 Vue 2.0 已经有显式的视觉表现过渡动画控制，所以移除)</li>
<li><code>suppressTransitionError</code> (因为钩子函数的系统的简化而移除)<br><strong>新的<code>made</code>选项取值为</strong>：</li>
<li><code>abstract</code></li>
<li><code>hash</code> 默认值</li>
<li><code>history</code><br>在不支持 <code>history.pushState</code> 的浏览器中, 路由器会自动回退为 <code>hash</code> 模式。<br><strong>已经作废的方法</strong></li>
<li><code>router.map</code>被 <code>routers</code>代替</li>
<li><code>router.beforeEach</code>被<code>beforeEach</code>代替，不过在<strong>beta2</strong>版本中有修改，见下面。</li>
<li><code>router，afterEach</code>被<code>afterEach</code>代替，不过在<strong>beta2</strong>版本中有修改，见下面。</li>
<li><code>router.redirect</code> (现在可以在 <code>routes</code> 中直接声明, 参见<a href="https://github.com/vuejs/vue-router/blob/43183911dedfbb30ebacccf2d76ced74d998448a/examples/redirect/app.js#L13-L39" target="_blank" rel="external">demo</a>)</li>
<li><code>router.alias</code> (现在可以在 <code>routes</code> 配置中直接声明, 参见<a href="https://github.com/vuejs/vue-router/blob/43183911dedfbb30ebacccf2d76ced74d998448a/examples/route-alias/app.js#L11-L26" target="_blank" rel="external">demo</a>)<br><strong>Beta 2</strong> 中，<code>beforeEach</code> 和 <code>afterEach</code> 又被改回成为 <code>router</code>的实例方法。作者说是这可以让插件和模块更加方便的在<code>router</code>实例创建后增加<code>hooks</code>。<h4 id="导航钩子函数"><a href="#导航钩子函数" class="headerlink" title="导航钩子函数"></a>导航钩子函数</h4>钩子系统被极大简化，所有0.7的迁移钩子都作废了，下面是替代方案：</li>
<li>使用组件自身的生命周期钩子函数来替代<code>activate</code> 和 <code>deactivate</code></li>
<li>在<code>$router</code> 上使用 <code>watcher</code> 来响应路由改变 ( 比如基于新的路由参数获取数据 <a href="https://github.com/vuejs/vue-router/tree/next/examples/data-fetching" target="_blank" rel="external">demo</a>)</li>
<li><code>canActivate</code> 可以被<code>router</code> 的配置中的 <code>beforeEnter</code> 中实现 <a href="https://github.com/vuejs/vue-router/blob/43183911dedfbb30ebacccf2d76ced74d998448a/examples/navigation-guards/app.js#L49" target="_blank" rel="external">demo</a></li>
<li><code>canDeactivate</code> 已经被 <code>beforeRouteLeave</code> 取代, 后者在一个组件的根级定义中指定。这个钩子函数在调用时是将组件的实例作为其上下文的。<a href="https://github.com/vuejs/vue-router/blob/43183911dedfbb30ebacccf2d76ced74d998448a/examples/navigation-guards/app.js#L35-L38" target="_blank" rel="external">demo</a></li>
<li><code>canReuse</code> 已经被移除，因其容易混淆且很少被用到。<br>此外，在2.0版本中所有的钩子函数都有相同简洁的签名：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">guard (toRoute, redirect, next) &#123;</div><div class="line">  <span class="comment">// call redirect to redirect to another route</span></div><div class="line">  <span class="comment">// call next to confirm current route</span></div><div class="line">  <span class="comment">// or do nothing to cancel the navigation</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>这些函数也不再支持返回 Promises。</p>
<p>####　链接（Links）<br>说说一个很大的变化，也是最先知道的变化。<br><code>v-link</code> 指令被 <code>&lt;router-link&gt;</code> 组件替代。 这个组件接受以下属性参数:</p>
<ul>
<li><code>to</code>: 一个路径字符串, 或者一个 <code>Location Descriptor</code> 对象。</li>
<li><code>tag</code>: 渲染为的 <code>html</code> 元素类型，默认是<code>&lt;a&gt;</code>。</li>
<li><code>exact</code>: 用于控制当前激活项的匹配行为（严格匹配或者贪婪匹配）.</li>
<li><code>append</code>: 控制相对链接路径的追加方式</li>
<li><code>replace</code>: 替代而不是作为历史条目压榨你</li>
<li><code>active-class</code>: 当链接项激活时增加的 CSS 样式<br>这里有个 复杂的例子 展示了<code>&lt;router-link&gt;</code>的用法。<h4 id="命名视图-Named-Views"><a href="#命名视图-Named-Views" class="headerlink" title="命名视图 (Named Views)"></a>命名视图 (Named Views)</h4>单个路由现在可以映射到多个命名组件。这些组件将会在渲染在对应命名的多个 <code>&lt;router-view&gt;</code>中。 <a href="https://github.com/vuejs/vue-router/blob/43183911dedfbb30ebacccf2d76ced74d998448a/examples/named-views/app.js" target="_blank" rel="external">Demo</a><br>(译者注）这个功能很赞，提供了一种新的用多个组件组成页面结构的方法，同时又不增加组件之间的耦合。<h4 id="滚动行为（Scroll-Behavior）"><a href="#滚动行为（Scroll-Behavior）" class="headerlink" title="滚动行为（Scroll Behavior）"></a>滚动行为（Scroll Behavior）</h4><code>scrollBehavior</code> 选项接受一个函数，返回在路由导航时控制页面如何滚动的规则。你可以代码控制是否要滚动的页面顶部、书签或者在状态中保存的位置。<a href="https://github.com/vuejs/vue-router/blob/43183911dedfbb30ebacccf2d76ced74d998448a/examples/scroll-behavior/app.js#L18-L38" target="_blank" rel="external">Demo</a></li>
</ul>
<p><strong>Beta2</strong> 版本中又对 <code>scrollBehavior</code> 做了修改:</p>
<p><strong>Beta1</strong> 中返回 <strong>{ hash: true }</strong> 来滚动到文档中的一个锚点，现在返回的是 <code>{ selector: route.hash }</code>。这也同时意味着你可以返回任意的 CSS 选择器，来匹配成要滚动到的目标。</p>
<p>此外，你还可以返回<strong>{ selector: ‘…’, x: 0, y: 0 }</strong>，这会让路由器首先尝试滚动到匹配的元素，如果没有找到匹配元素，那就滚动到 x和y指定的位置。</p>
]]></content>
      
        
        <tags>
            
            <tag> vue </tag>
            
            <tag> vue-router </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[vue-router（一）：实例化一个简单地vue-router]]></title>
      <url>/year/06/06/vue-router%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E5%9C%B0vue-router%E5%AE%9E%E4%BE%8B/</url>
      <content type="html"><![CDATA[<p>最近开始学习 <strong>vue-router</strong>，因为自己参照的范本是<strong>vue-router 1.0</strong>，但是自己<strong>npm</strong>的是<strong>2.0</strong>的版本，所以只好自己按照官方文档自己修改，学习过程中按照官方文档来遇到了很多问题，因为自己用的方法是<strong>import</strong>的组件，而官方提供的方法是<code>const Bar = { template: &#39;&lt;div&gt;bar&lt;/div&gt;&#39; }</code>这种，自己定义的标签模板，因为在项目中使用的大多是<strong>import</strong>的模板，所以只好自己慢慢修改。<br><a id="more"></a><br>先来一个官方的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt;</div><div class="line"></div><div class="line">&lt;div id=&quot;app&quot;&gt;</div><div class="line">  &lt;h1&gt;Hello App!&lt;/h1&gt;</div><div class="line">  &lt;p&gt;</div><div class="line">    &lt;!-- 使用 router-link 组件来导航. --&gt;</div><div class="line">    &lt;!-- 通过传入 `to` 属性指定链接. --&gt;</div><div class="line">    &lt;!-- &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签 --&gt;</div><div class="line">    &lt;router-link to=&quot;/foo&quot;&gt;Go to Foo&lt;/router-link&gt;</div><div class="line">    &lt;router-link to=&quot;/bar&quot;&gt;Go to Bar&lt;/router-link&gt;</div><div class="line">  &lt;/p&gt;</div><div class="line">  &lt;!-- 路由出口 --&gt;</div><div class="line">  &lt;!-- 路由匹配到的组件将渲染在这里 --&gt;</div><div class="line">  &lt;router-view&gt;&lt;/router-view&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 代码是在 main.js</span></div><div class="line"><span class="comment">// 0. 如果使用模块化机制编程，導入Vue和VueRouter，要调用 Vue.use(VueRouter)</span></div><div class="line"></div><div class="line"><span class="comment">// 1. 定义（路由）组件。</span></div><div class="line"><span class="comment">// 可以从其他文件 import 进来</span></div><div class="line"><span class="keyword">const</span> Foo = &#123; <span class="attr">template</span>: <span class="string">'&lt;div&gt;foo&lt;/div&gt;'</span> &#125;</div><div class="line"><span class="keyword">const</span> Bar = &#123; <span class="attr">template</span>: <span class="string">'&lt;div&gt;bar&lt;/div&gt;'</span> &#125;</div><div class="line"></div><div class="line"><span class="comment">// 2. 定义路由</span></div><div class="line"><span class="comment">// 每个路由应该映射一个组件。 其中"component" 可以是</span></div><div class="line"><span class="comment">// 通过 Vue.extend() 创建的组件构造器，</span></div><div class="line"><span class="comment">// 或者，只是一个组件配置对象。</span></div><div class="line"><span class="comment">// 我们晚点再讨论嵌套路由。</span></div><div class="line"><span class="keyword">const</span> routes = [</div><div class="line">  &#123; <span class="attr">path</span>: <span class="string">'/foo'</span>, <span class="attr">component</span>: Foo &#125;,</div><div class="line">  &#123; <span class="attr">path</span>: <span class="string">'/bar'</span>, <span class="attr">component</span>: Bar &#125;</div><div class="line">]</div><div class="line"></div><div class="line"><span class="comment">// 3. 创建 router 实例，然后传 `routes` 配置</span></div><div class="line"><span class="comment">// 你还可以传别的配置参数, 不过先这么简单着吧。</span></div><div class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</div><div class="line">  routes <span class="comment">// （缩写）相当于 routes: routes</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 4. 创建和挂载根实例。</span></div><div class="line"><span class="comment">// 记得要通过 router 配置参数注入路由，</span></div><div class="line"><span class="comment">// 从而让整个应用都有路由功能</span></div><div class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</div><div class="line">  router</div><div class="line">&#125;).$mount(<span class="string">'#app'</span>)</div><div class="line"></div><div class="line"><span class="comment">// 现在，应用已经启动了！</span></div></pre></td></tr></table></figure>
<blockquote>
<p>可以看出来，官方给的例子中，是自己定义的 <strong>template</strong> 模板，然而我们项目中很少这样用。<br>看一下用 <strong>import</strong> 的方法怎么用。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// The Vue build version to load with the `import` command</span></div><div class="line"><span class="comment">// (runtime-only or standalone) has been set in webpack.base.conf with an alias.</span></div><div class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</div><div class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">'vue-router'</span>;</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">'./common/sylus/index.styl'</span>; <span class="comment">// 引用 stylus 样式文件</span></div><div class="line"></div><div class="line"><span class="comment">// 0. 如果使用模块化机制编程，導入Vue和VueRouter，要调用 Vue.use(VueRouter)</span></div><div class="line">Vue.use(VueRouter);</div><div class="line"></div><div class="line"><span class="comment">// 1. 定义（路由）组件。</span></div><div class="line"><span class="comment">// 可以从其他文件 import 进来</span></div><div class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span>;</div><div class="line"><span class="keyword">import</span> goods <span class="keyword">from</span> <span class="string">'./components/goods/goods'</span>;</div><div class="line"><span class="keyword">import</span> ratings <span class="keyword">from</span> <span class="string">'./components/ratings/ratings'</span>;</div><div class="line"><span class="keyword">import</span> seller <span class="keyword">from</span> <span class="string">'./components/seller/seller'</span>;</div><div class="line"></div><div class="line"><span class="comment">// 2. 定义路由</span></div><div class="line"><span class="comment">// 每个路由应该映射一个组件。 其中"component" 可以是</span></div><div class="line"><span class="comment">// 通过 Vue.extend() 创建的组件构造器，</span></div><div class="line"><span class="comment">// 或者，只是一个组件配置对象。</span></div><div class="line"><span class="comment">// 我们晚点再讨论嵌套路由。</span></div><div class="line"><span class="comment">// 设置组件的路由路径</span></div><div class="line"><span class="keyword">const</span> routes = [</div><div class="line">  &#123; <span class="attr">path</span>: <span class="string">'/goods'</span>, <span class="attr">component</span>: goods &#125;,</div><div class="line">  &#123; <span class="attr">path</span>: <span class="string">'/ratings'</span>, <span class="attr">component</span>: ratings &#125;,</div><div class="line">  &#123; <span class="attr">path</span>: <span class="string">'/seller'</span>, <span class="attr">component</span>: seller &#125;</div><div class="line">];</div><div class="line"></div><div class="line"><span class="comment">// 3. 创建 router 实例，然后传 `routes` 配置</span></div><div class="line"><span class="comment">// 你还可以传别的配置参数, 不过先这么简单着吧。</span></div><div class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</div><div class="line">  routes, <span class="comment">// （缩写）相当于 routes: routes 实际上是把上面的 routers 实例化一下 然后放在下面</span></div><div class="line">  linkActiveClass: <span class="string">'active'</span> <span class="comment">// 路由配置选项 可以设置店里的 a 标签的class</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 4. 创建和挂载根实例。</span></div><div class="line"><span class="comment">// 记得要通过 router 配置参数注入路由，</span></div><div class="line"><span class="comment">// 从而让整个应用都有路由功能</span></div><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  <span class="attr">el</span>: <span class="string">'#app'</span>, <span class="comment">// 挂载到 #app 上</span></div><div class="line">  template: <span class="string">'&lt;App/&gt;'</span>, <span class="comment">// 模板为 App</span></div><div class="line">  components: &#123; App &#125;, <span class="comment">// 组件为 App</span></div><div class="line">  router <span class="comment">// 传入实例化的router</span></div><div class="line">&#125;).$mount(<span class="string">'#app'</span>);</div><div class="line">router.push(<span class="string">'/goods'</span>); <span class="comment">// 指定默认路由</span></div><div class="line"><span class="comment">// 现在，应用已经启动了！</span></div></pre></td></tr></table></figure></p>
</blockquote>
<p>上面就是<strong>vue-router 2.0</strong>的用 <strong>import</strong> 的方法，与官方文档不同，但与我们项目中的开发方式相同。</p>
]]></content>
      
        
        <tags>
            
            <tag> vue </tag>
            
            <tag> vue-router </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[TypeScript初试]]></title>
      <url>/year/05/20/TypeScript%E5%88%9D%E8%AF%95/</url>
      <content type="html"><![CDATA[<h3 id="字符串新特性"><a href="#字符串新特性" class="headerlink" title="字符串新特性"></a>字符串新特性</h3><h4 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h4><p>普通<code>javascript</code>代码中，字符串换行会报错，要用双撇号声明多行字符串，即<code>`` </code> ，即数字1左边的按键<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> content = <span class="string">"aaaa"</span>+</div><div class="line">    <span class="string">"cccc"</span></div><div class="line"><span class="keyword">var</span> content2 = <span class="string">`aaaa</span></div><div class="line">                ccc</div><div class="line">                bbb`</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<h4 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myname = <span class="string">'lin'</span></div><div class="line"><span class="keyword">var</span> getage = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="number">18</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">`My name is <span class="subst">$&#123;myname&#125;</span>`</span>)</div><div class="line"><span class="built_in">console</span>.log(<span class="string">`My age is <span class="subst">$&#123;getage()&#125;</span>`</span>)</div></pre></td></tr></table></figure>
<p>那么多行字符串有什么威力呢？<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">`&lt;div&gt;</span></div><div class="line">&lt;span&gt;<span class="subst">$&#123;myname&#125;</span>&lt;/span&gt;</div><div class="line">&lt;span&gt;<span class="subst">$&#123;getage()&#125;</span>&lt;/span&gt;</div><div class="line">&lt;/div&gt;`)</div></pre></td></tr></table></figure></p>
<p>这样，如果你在项目中，要定义一个<code>html</code>模板，是不是很轻松呢，不用费力的输入引号和加号了，是不是很赞。</p>
<h4 id="自动拆分字符串"><a href="#自动拆分字符串" class="headerlink" title="自动拆分字符串"></a>自动拆分字符串</h4><p>那么，什么是自动拆分字符串呢，当你在用一个字符串模板去调用一个方法的时候，这个字符串模板里面表达式的值会自动赋给被调用方法中的参数吗，听起来有点迷糊，看例子。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">template, name, age</span>) </span>&#123; </div><div class="line">    <span class="built_in">console</span>.log(template)</div><div class="line">    <span class="built_in">console</span>.log(name)</div><div class="line">    <span class="built_in">console</span>.log(age)</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> myname = <span class="string">'lin'</span></div><div class="line"><span class="keyword">var</span> getage = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">18</span></div><div class="line">&#125;</div><div class="line">test<span class="string">`my name is <span class="subst">$&#123;myname&#125;</span>,i'm <span class="subst">$&#123;getage()&#125;</span></span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：如果第一个 <code>template</code> 变量不写，也就是<code>text</code>只有两个变量，则<code>getage</code>无法显示。</p>
</blockquote>
<h3 id="参数新特性"><a href="#参数新特性" class="headerlink" title="参数新特性"></a>参数新特性</h3><h4 id="参数类型"><a href="#参数类型" class="headerlink" title="参数类型"></a>参数类型</h4><p>在参数名称后面使用冒号来指定参数的类型<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myname: <span class="built_in">string</span> = <span class="string">'lin'</span></div></pre></td></tr></table></figure></p>
<h4 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h4><p>在参数声明后面用等号来指定参数的默认值</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myname: <span class="built_in">string</span> = <span class="string">'lin'</span></div></pre></td></tr></table></figure>
<p>给方法的变量指定默认值<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function test(a: string, b: string, c: string = 'lin') &#123;</div><div class="line">    console.log(a)</div><div class="line">    console.log(b)</div><div class="line">    console.log(c)</div><div class="line">&#125;</div><div class="line">test('x', 'y', 'z')</div></pre></td></tr></table></figure></p>
<blockquote>
<p>默认三个参数后，必须传三个参数，否则会报错，如果指定了默认值，则可以传两个,而且默认参数必须为最后一个，否则会报错。</p>
</blockquote>
<h4 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h4><p>在方法的参数声明后面用问号来标明此参数为可选参数<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function test(a: string, b?: string , c: string = 'lin') &#123;</div><div class="line">    console.log(a)</div><div class="line">    console.log(b)</div><div class="line">    console.log(c)</div><div class="line">&#125;</div><div class="line">test('x')</div></pre></td></tr></table></figure></p>
<blockquote>
<p>因为<code>b</code>参数是可选的，<code>c</code>参数是默认的，所以就可以传一个值<br>注意：</p>
<ul>
<li>要处理<code>可选参数</code>没传值的情况，比如<code>b</code>没传值，而<code>console.log(b.length)</code>这个时候会报错。可选参数默认是<code>undefined</code>。</li>
<li><code>可选参数</code>不能声明在<code>必选参数</code>前面的，要跟<code>默认参数</code>一样，声明在不选<code>参数后面</code><h3 id="函数新特性"><a href="#函数新特性" class="headerlink" title="函数新特性"></a>函数新特性</h3><h4 id="Rest-and-Spread操作符"><a href="#Rest-and-Spread操作符" class="headerlink" title="Rest and Spread操作符"></a>Rest and Spread操作符</h4>用来声明任意数量的方法参数<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params">...args</span>) </span>&#123;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<p><code>...args</code>即操作符，可以传任意数量的参数给<code>func1</code>函数。<br><code>...args</code>即<code>JavaScript</code>的<code>arguments</code>对象</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params">...args</span>) </span>&#123;</div><div class="line">    args.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">arg</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(arg)</div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上<code>TypeScript</code>代码转化为<code>JavaScript</code>代码为<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> args = [];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> _i = <span class="number">0</span>; _i &lt; <span class="built_in">arguments</span>.length; _i++) &#123;</div><div class="line">        args[_i] = <span class="built_in">arguments</span>[_i];</div><div class="line">    &#125;</div><div class="line">    args.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">arg</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(arg);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> <strong>ES6 <code>...args</code>用法</strong><br> 在ES6中，<code>...args</code>用法是函数参数确定，可以把任意数量的数组，转化成一个固定数量参数的函数，如果数组不够参数数量，则多余的参数为<code>undefined</code>，多的则自动剔除。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params">a, b, c</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(a);</div><div class="line">    <span class="built_in">console</span>.log(b);</div><div class="line">    <span class="built_in">console</span>.log(c);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> args = [<span class="number">1</span>, <span class="number">2</span>];</div><div class="line">func1(...args);</div><div class="line"><span class="keyword">var</span> args2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>];</div><div class="line">func1(...args2);</div></pre></td></tr></table></figure></p>
<h4 id="generator函数"><a href="#generator函数" class="headerlink" title="generator函数"></a>generator函数</h4><p>控制函数的执行过程，手工暂停和恢复代码执行<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">doSomething</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 函数后面的 * 必须有</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'start'</span>);</div><div class="line">  <span class="keyword">yield</span>; <span class="comment">//类似于打断点</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'finish'</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> func1 = doSomething(); <span class="comment">// 直接调用 doSomething()方法无效，必须定义给一个变量，然后调用变量的 next() 方法</span></div><div class="line">func1.next();</div><div class="line"><span class="comment">// 遇见 yield 停住</span></div><div class="line">func1.next();</div></pre></td></tr></table></figure></p>
<h4 id="结构表达式"><a href="#结构表达式" class="headerlink" title="结构表达式"></a>结构表达式</h4><p>通过表达式将对象或数组拆解成任意数量的变量<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getStock</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        code: <span class="string">'IBM'</span>,</div><div class="line">        price: <span class="number">100</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在<code>JavaScript</code>中要获取对象值要这样写：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> stock = getStock();</div><div class="line"><span class="keyword">var</span> code = stock.code;</div><div class="line"><span class="keyword">var</span> price = stock.price;</div></pre></td></tr></table></figure></p>
<p>在<code>TypeScript</code>中，有一种新的语法：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> &#123; code, price &#125; = getStock();</div></pre></td></tr></table></figure></p>
<p>这样一行代码就可以完成上面三行代码完成的事情。</p>
<blockquote>
<p>注意：<br> <code>{}</code>中的变量要跟定义函数中的对象变量名字一致<br>        如果非要自己给以名字，可以写成<code>var { code: codeX, price } = getStock();</code> 意思就是说从对象中取出<code>code</code>属性，然后放在本地一个叫<code>codeX</code>的变量中。</p>
<h5 id="如何取一个嵌套的属性"><a href="#如何取一个嵌套的属性" class="headerlink" title="如何取一个嵌套的属性"></a>如何取一个嵌套的属性</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getStock</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        code: <span class="string">'IBM'</span>,</div><div class="line">        price: &#123;</div><div class="line">			price1: <span class="number">200</span>,</div><div class="line">			price2: <span class="number">300</span></div><div class="line">		&#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> &#123; code, price: &#123;price2&#125; &#125; = getStock();</div></pre></td></tr></table></figure>
<p>只需要在变量后面在添加一个解构表达式， <code>对象: {对象}</code></p>
</blockquote>
<p>如果函数中还有别的属性，只要解构表达式中的变量名没错，即使没有调用到别的属性，也并不妨碍解构表达式正常工作。</p>
<h5 id="基于数组的解构表达式"><a href="#基于数组的解构表达式" class="headerlink" title="基于数组的解构表达式"></a>基于数组的解构表达式</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line"><span class="keyword">var</span> [number1, number2] = arr1;</div><div class="line"><span class="built_in">console</span>.log(number1);</div><div class="line"><span class="built_in">console</span>.log(number2);</div></pre></td></tr></table></figure>
<blockquote>
<p><code>number1</code>,<code>number2</code>只是变量名，不是对应数组下标，如果我只是想取数组后两个值，写法如下;<br> <code>var [ , , number1, number2] = arr1;</code><br>用 <code>，</code>，值为空隔开。<br>解构表达式与<code>rest</code>操作符（…args）<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line"><span class="keyword">var</span> [number1, number2, ...args] = arr1;</div><div class="line"><span class="built_in">console</span>.log(number1);</div><div class="line"><span class="built_in">console</span>.log(number2);</div><div class="line"><span class="built_in">console</span>.log(args);</div></pre></td></tr></table></figure></p>
</blockquote>
<h5 id="把解构表达式作为方法的参数"><a href="#把解构表达式作为方法的参数" class="headerlink" title="把解构表达式作为方法的参数"></a>把解构表达式作为方法的参数</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line"><span class="keyword">var</span> [number1, number2] = arr1;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">[<span class="built_in">number</span>, number2, ...args]</span>) </span>&#123;   </div><div class="line"><span class="built_in">console</span>.log(number1);</div><div class="line"><span class="built_in">console</span>.log(number2);</div><div class="line"><span class="built_in">console</span>.log(args);</div><div class="line">&#125;</div><div class="line">doSomething(arr1);</div></pre></td></tr></table></figure>
<blockquote>
<p>函数参数是解构表达式，那么这个方法会根据这个解构表达式，把传进来的数组拆分成相应的变量</p>
<h3 id="箭头表达式"><a href="#箭头表达式" class="headerlink" title="箭头表达式"></a>箭头表达式</h3><p>用来声明匿名函数，消除传统匿名函数的<code>this</code>指针问题<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">arg1, arg2</span>) =&gt;</span> arg1 + arg2;</div></pre></td></tr></table></figure></p>
<p>如果方法里只有一行，可以不用写<code>{}</code>，也不需要写<code>return</code>关键字。<br>如果函数是多行，也需要写<code>{}</code>和<code>return</code>关键字。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">arg1, arg2</span>) =&gt;</span> &#123;</div><div class="line">	<span class="keyword">return</span> arg1 + arg2;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<ol>
<li><p>无参数箭头表达式</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sum = <span class="function"><span class="params">()</span> =&gt;</span> &#123; &#125;;</div></pre></td></tr></table></figure>
</li>
<li><p>只有一个参数时，可以不用写<code>（）</code>，直接写参数的变量名即可</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sum = <span class="function"><span class="params">arg</span> =&gt;</span> &#123; </div><div class="line">	<span class="built_in">console</span>.log(arg)</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>实际应用<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myArr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line"><span class="built_in">console</span>.log(myArr.filter(<span class="function"><span class="params">value</span> =&gt;</span> value%<span class="number">2</span> == <span class="number">0</span>))</div></pre></td></tr></table></figure></p>
<p>消除<code>this</code>困扰<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getStock</span>(<span class="params">name: <span class="built_in">string</span></span>) </span>&#123; </div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    setInterval( <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'name is'</span> + <span class="keyword">this</span>.name)</div><div class="line">    &#125;,<span class="number">1000</span>)</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> stock = <span class="keyword">new</span> getStock(<span class="string">'NBA'</span>);</div></pre></td></tr></table></figure></p>
<p>普通的<code>JavaScript</code>代码不会显示任何东西<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getStock</span>(<span class="params">name: string</span>) </span>&#123; </div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    setInterval( <span class="function"><span class="keyword">function</span>(<span class="params"></span>) =&gt; </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'name is'</span> + <span class="keyword">this</span>.name)</div><div class="line">    &#125;,<span class="number">1000</span>)</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> stock = <span class="keyword">new</span> getStock(<span class="string">'NBA'</span>);</div></pre></td></tr></table></figure></p>
<h4 id="for-of循环"><a href="#for-of循环" class="headerlink" title="for of循环"></a><code>for of</code>循环</h4><p><code>for of</code>跟<code>for in</code>循环一样，只不过不会循环自写属性。</p>
<h3 id="面向对象特性"><a href="#面向对象特性" class="headerlink" title="面向对象特性"></a>面向对象特性</h3><h4 id="类（class）"><a href="#类（class）" class="headerlink" title="类（class）"></a>类（<code>class</code>）</h4><p>类是<code>TypeScript</code>的核心，使用<code>TypeScript</code>开发时，大部分代码都是写在类里面的。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Person&#123;</div><div class="line">    name: <span class="string">'lin'</span>;</div><div class="line">    eat() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'eat'</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</div><div class="line"><span class="built_in">console</span>.log(p1.name = <span class="string">'lin'</span>);</div><div class="line">p1.eat();</div></pre></td></tr></table></figure></p>
<blockquote>
<p>访问控制符，控制类的属性和方法是否可以在类的外部访问。默认<code>public</code>，<code>private</code> 只有在类的内部可以访问。<code>protected</code>受保护的，可以在类的内部和他的子类访问，在类的外部也不能访问。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Person&#123;</div><div class="line">    <span class="keyword">private</span> name = <span class="string">'lin'</span>;</div><div class="line">    eat() &#123;</div><div class="line">        <span class="built_in">console</span>.log(name)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="类的构造函数"><a href="#类的构造函数" class="headerlink" title="类的构造函数"></a>类的构造函数</h4><p>关键字<code>constructork</code><br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Person&#123;</div><div class="line">	<span class="keyword">constructor</span>(<span class="params"></span>)&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="string">'lin'</span>)</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</div></pre></td></tr></table></figure></p>
<blockquote>
<p><code>constructor</code>方法只有在类被实例化（<code>new</code>）的时候才会被调用，而且只被调用一次。<code>constructor</code>不能在外边调用。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Person&#123;</div><div class="line">	<span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">    name;</div><div class="line">    eat() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'lin'</span>);</div><div class="line">p1.eat();</div></pre></td></tr></table></figure></p>
</blockquote>
<p>简化<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Person&#123;</div><div class="line">	<span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span></span>)&#123; <span class="comment">//明确声明public</span></div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    eat() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'lin'</span>);</div><div class="line">p1.eat();</div></pre></td></tr></table></figure></p>
<h4 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h4><p><code>extends</code>用来声明类的继承关系，<code>super</code>用来调用父类的构造函数和方法。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Person&#123;</div><div class="line">	<span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">    name;</div><div class="line">    eat() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">class</span> Employee <span class="keyword">extends</span> Person&#123;</div><div class="line">    code: <span class="built_in">string</span>;</div><div class="line">    work() &#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'lin'</span>);</div><div class="line">p1.eat();</div><div class="line"><span class="keyword">var</span> e1 = <span class="keyword">new</span> Employee(<span class="string">'name '</span>)</div><div class="line">e1.eat();</div><div class="line">e1.work();</div></pre></td></tr></table></figure></p>
<p><code>super</code>第一个用法是用来调用父类的构造函数<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Person&#123;</div><div class="line">	<span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'lin'</span>);</div><div class="line">    &#125;</div><div class="line">    name;</div><div class="line">    eat() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'eating'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">class</span> Employee <span class="keyword">extends</span> Person&#123;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, code: <span class="built_in">string</span></span>) &#123;</div><div class="line">        <span class="keyword">super</span>(name);<span class="comment">//子类的构造函数必须继承父类的构造函数</span></div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'alin'</span>)</div><div class="line">        <span class="keyword">this</span>.code = code;</div><div class="line">    &#125;</div><div class="line">    code: <span class="built_in">string</span>;</div><div class="line">    work() &#123;</div><div class="line">        <span class="keyword">super</span>.eat();</div><div class="line">        <span class="keyword">this</span>.doWork();</div><div class="line">    &#125;</div><div class="line">    doWork() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'working'</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'lin'</span>);</div><div class="line">p1.eat();</div><div class="line"><span class="keyword">var</span> e1 = <span class="keyword">new</span> Employee(<span class="string">'name '</span>, <span class="string">'1'</span>)</div><div class="line">e1.eat();</div><div class="line">e1.work();</div></pre></td></tr></table></figure></p>
<h4 id="泛型（generic）"><a href="#泛型（generic）" class="headerlink" title="泛型（generic）"></a>泛型（generic）</h4><p>参数化的类型，一般来限制集合的内容。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Person&#123;</div><div class="line">	<span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'lin'</span>);</div><div class="line">    &#125;</div><div class="line">    name;</div><div class="line">    eat() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'eating'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">class</span> Employee <span class="keyword">extends</span> Person&#123;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, code: <span class="built_in">string</span></span>) &#123;</div><div class="line">        <span class="keyword">super</span>(name);<span class="comment">//子类的构造函数必须继承父类的构造函数</span></div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'alin'</span>)</div><div class="line">        <span class="keyword">this</span>.code = code;</div><div class="line">    &#125;</div><div class="line">    code: <span class="built_in">string</span>;</div><div class="line">    work() &#123;</div><div class="line">        <span class="keyword">super</span>.eat();</div><div class="line">        <span class="keyword">this</span>.doWork();</div><div class="line">    &#125;</div><div class="line">    doWork() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'working'</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// var p1 = new Person('lin');</span></div><div class="line"><span class="comment">// p1.eat();</span></div><div class="line"><span class="comment">// var e1 = new Employee('name ', '1')</span></div><div class="line"><span class="comment">// e1.eat();</span></div><div class="line"><span class="comment">// e1.work();</span></div><div class="line"><span class="keyword">var</span> workers: <span class="built_in">Array</span>&lt;Person&gt; = [];<span class="comment">// 用 &lt;&gt; 括起来的类型person 就是数组的泛型 规定数组里只能放person</span></div><div class="line">workers[<span class="number">0</span>] = <span class="keyword">new</span> Person(<span class="string">'linlin'</span>);</div><div class="line">workers[<span class="number">1</span>] = <span class="keyword">new</span> Employee(<span class="string">'alin'</span>,<span class="string">'2'</span>);</div></pre></td></tr></table></figure></p>
<h4 id="接口（Interface）"><a href="#接口（Interface）" class="headerlink" title="接口（Interface）"></a>接口（Interface）</h4><p>用来建立某种代码约定，使得其他开发者在调用某个方法或者创建新的类时必须遵循接口所定义的代码约定。声明接口<code>interface</code>，<code>implements</code><br>当接口用做方法的参数的类型声明时，当你在调用这个方法的时候，<code>TypeScript</code>会检查传入的参数是否满足接口所声明的所有属性。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> Iperson&#123;</div><div class="line">    name: <span class="built_in">string</span>;</div><div class="line">    age: <span class="built_in">number</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">class</span> Person&#123;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> config: Iperson</span>) &#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(&#123;</div><div class="line">    name: <span class="string">'lin'</span>,</div><div class="line">    age: <span class="number">18</span></div><div class="line">&#125;);<span class="comment">//实例化的时候必须传一个对象进去</span></div></pre></td></tr></table></figure></p>
<p>用接口来声明方法<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> Anmial&#123;</div><div class="line">    eat();</div><div class="line">&#125;</div><div class="line"><span class="keyword">class</span> Sheep <span class="keyword">implements</span> Anmial&#123;</div><div class="line">    eat() &#123; </div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'eat'</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">class</span> TigerTiger  <span class="keyword">implements</span> Anmial&#123;</div><div class="line">    eat() &#123; </div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'eat'</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4><p>模块可以帮助开发者将代码分割为可重用的单元。开发者可以自己决定将模块中的哪些资源（类、方法、变量）暴露出去供外部使用，哪些资源只能在模块内使用。<br>新建两个文件<code>a.ts</code> <code>b.ts</code><br><code>a.ts</code><br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span>  <span class="keyword">var</span> prop1; <span class="comment">//暴露</span></div><div class="line"><span class="keyword">var</span> prop2; <span class="comment">//不暴露</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func2</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="keyword">export</span>  <span class="keyword">class</span> Class1&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="keyword">class</span> Class2&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>b.ts</code><br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;prop1, Class1&#125; <span class="keyword">from</span> <span class="string">"./a"</span>;</div><div class="line"><span class="built_in">console</span>.log(prop1); <span class="comment">// a.ts没有暴露的不可以在 b.ts中引用</span></div><div class="line">func1();</div><div class="line"><span class="keyword">new</span> Class1();</div></pre></td></tr></table></figure></p>
<h4 id="注解（annotation）"><a href="#注解（annotation）" class="headerlink" title="注解（annotation）"></a>注解（annotation）</h4><p>注解为程序的元素（类、方法、变量）加上更直观明了的说明，这些说明信息与程序的业务逻辑无关，而是供特定的工具或框架使用的。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span>  &#123; Component &#125; <span class="keyword">from</span>  <span class="string">'@angular/core'</span>;</div><div class="line"><span class="meta">@Component</span>(&#123;</div><div class="line">    selector: <span class="string">'app-root'</span>,</div><div class="line">    templateUrl: <span class="string">'./app.componern.html'</span>, <span class="comment">//告诉angular框架引用这个文件。</span></div><div class="line">    styleUrls: <span class="string">'./app.componern.css'</span>,</div><div class="line">&#125;)</div><div class="line"><span class="keyword">export</span>  <span class="keyword">class</span> AppComonent&#123;</div><div class="line">    title = <span class="string">'app Works'</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="类型定义文件（-d-ts）"><a href="#类型定义文件（-d-ts）" class="headerlink" title="类型定义文件（*.d.ts）"></a>类型定义文件（*.d.ts）</h4><p>类型定义文件用来帮助开发者在<code>TypeScript</code>中使用已有的<code>JavaScript</code>工具包，如：<code>JQuery</code>。<br>有一个工具便于大家使用类型定义文件-<a href="https://github.com/typings/typings" target="_blank" rel="external">Typings</a></p>
]]></content>
      
        
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HTML5 Canvas 机器猫效果]]></title>
      <url>/year/05/12/%E6%9C%BA%E5%99%A8%E7%8C%AB/</url>
      <content type="html"><![CDATA[<p>最近在网上看见了一个用Canvas画的机器猫，觉得很有意思，加上自己也在学习Canvas画图，就顺手写了个。</p>
<p><a href="https://codepen.io/jiangxiaolin1995/pen/QvBWKG" target="_blank" rel="external">先看Demo</a><br><a id="more"></a><br>废话不多说，直接上代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset="utf-8"/&gt;</div><div class="line">    &lt;title&gt;哆啦A梦&lt;/title&gt;</div><div class="line">    &lt;style&gt;</div><div class="line">        body &#123;</div><div class="line">            margin: 0;</div><div class="line">            padding: 0;</div><div class="line">        &#125;</div><div class="line">        #doraemon &#123;</div><div class="line">            background-color: #fff;</div><div class="line">            display: block;</div><div class="line">        &#125;</div><div class="line">        canvas&#123;</div><div class="line">          margin: 10px auto;</div><div class="line">        &#125;</div><div class="line">    &lt;/style&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;canvas id="doraemon" width="400" height="600"&gt;&lt;/canvas&gt;</div><div class="line">&lt;div id="put" style="width: 50px" height="20px"&gt;&lt;/div&gt;</div><div class="line">&lt;script&gt;</div><div class="line">    window.onload = function () &#123;</div><div class="line">        var cxt = document.getElementById('doraemon').getContext('2d');</div><div class="line">        /* 头部*/</div><div class="line">        cxt.beginPath();//起始路径</div><div class="line">        cxt.lineWidth = 1;//线宽度为1</div><div class="line">        cxt.strokeStyle = '#000';//笔触的颜色</div><div class="line">        cxt.arc(200, 175, 175, 0.7 * Math.PI, 0.3 * Math.PI);//绘制弧，中心点（200，175），半径175</div><div class="line">        cxt.fillStyle = '#0bb0da';//设置填充时的颜色</div><div class="line">        cxt.fill();//填充颜色</div><div class="line">        cxt.stroke();//绘制路径</div><div class="line">        /*脸部*/</div><div class="line">        cxt.beginPath();</div><div class="line">        cxt.fillStyle = '#fff';</div><div class="line">        cxt.moveTo(110, 110);//将路径移到点（110，110），不创建线条</div><div class="line">        cxt.quadraticCurveTo(-10, 200, 120, 315);//创建二次贝塞尔曲线,控制点(-10,200),结束点(120,315)</div><div class="line">        cxt.lineTo(280, 315);//添加一个新点，然后在画布中创建从（110，110）到（280，315）的线条</div><div class="line">        cxt.quadraticCurveTo(410, 210, 290, 110);</div><div class="line">        cxt.lineTo(110, 110);</div><div class="line">        cxt.fill();</div><div class="line">        cxt.stroke();</div><div class="line">        /*眼睛*/</div><div class="line">        cxt.beginPath();</div><div class="line">        cxt.lineWidth = 1;</div><div class="line">        cxt.fillStyle = '#fff';</div><div class="line">        cxt.moveTo(110, 110);</div><div class="line">        cxt.bezierCurveTo(110, 25, 200, 25, 200, 100);//创建三次贝塞尔曲线,控制点1(110,25),控制点2(200,25),结束点(200,100)，也就是画左上半椭圆</div><div class="line">        cxt.bezierCurveTo(200, 175, 110, 175, 110, 100);//画左下半椭圆</div><div class="line">        cxt.moveTo(200, 100);</div><div class="line">        cxt.bezierCurveTo(200, 25, 290, 25, 290, 100);</div><div class="line">        cxt.bezierCurveTo(290, 175, 200, 175, 200, 100);</div><div class="line">        cxt.fill();</div><div class="line">        cxt.stroke();</div><div class="line">        /*右眼球*/</div><div class="line">        cxt.beginPath();</div><div class="line">        cxt.fillStyle = '#000';</div><div class="line">        cxt.arc(230, 130, 12, 0, 2 * Math.PI);</div><div class="line">        cxt.fill();</div><div class="line">        cxt.stroke();</div><div class="line">        /*左眼球*/</div><div class="line">        cxt.beginPath();</div><div class="line">        cxt.fillStyle = '#000';</div><div class="line">        cxt.arc(170, 130, 12, 0, 2 * Math.PI);</div><div class="line">        cxt.fill();</div><div class="line">        cxt.stroke();</div><div class="line">        /* 鼻子*/</div><div class="line">        cxt.beginPath();</div><div class="line">        cxt.arc(200, 165, 25, 0, 2 * Math.PI);</div><div class="line">        cxt.fillStyle = '#d05823';</div><div class="line">        cxt.fill();</div><div class="line">        cxt.stroke();</div><div class="line">        /*胡须*/</div><div class="line">        //左胡须</div><div class="line">        cxt.beginPath();</div><div class="line">        cxt.moveTo(80, 175);</div><div class="line">        cxt.lineTo(150, 195);</div><div class="line">        cxt.moveTo(80, 200);</div><div class="line">        cxt.lineTo(150, 205);</div><div class="line">        cxt.moveTo(80, 225);</div><div class="line">        cxt.lineTo(150, 215);</div><div class="line">        //中部胡须</div><div class="line">        cxt.moveTo(200, 195);</div><div class="line">        cxt.lineTo(200, 290);</div><div class="line">        //右胡须</div><div class="line">        cxt.moveTo(250, 195);</div><div class="line">        cxt.lineTo(320, 175);</div><div class="line">        cxt.moveTo(250, 205);</div><div class="line">        cxt.lineTo(320, 200);</div><div class="line">        cxt.moveTo(250, 215);</div><div class="line">        cxt.lineTo(320, 225);</div><div class="line">        cxt.stroke();</div><div class="line">        /*嘴*/</div><div class="line">        cxt.moveTo(80, 240);</div><div class="line">        cxt.quadraticCurveTo(200, 350, 320, 240);</div><div class="line">        cxt.stroke();</div><div class="line">        /*围巾*/</div><div class="line">        cxt.beginPath();</div><div class="line">        cxt.moveTo(96, 316);</div><div class="line">        cxt.lineTo(305, 316);</div><div class="line">        cxt.lineTo(320, 316);</div><div class="line">        cxt.arcTo(330, 316, 330, 326, 10);//在画布上创建介于两个切线之间的弧，起点坐标为(330,316),终点坐标为(330,326),半径为10</div><div class="line">        cxt.lineTo(330, 336);</div><div class="line">        cxt.arcTo(330, 346, 305, 346, 10);</div><div class="line">        cxt.lineTo(81, 346);</div><div class="line">        cxt.arcTo(71, 346, 71, 336, 10);</div><div class="line">        cxt.lineTo(71, 326);</div><div class="line">        cxt.arcTo(71, 316, 81, 316, 10);</div><div class="line">        cxt.lineTo(96, 316);</div><div class="line">        cxt.fillStyle = '#b13209';</div><div class="line">        cxt.fill();</div><div class="line">        cxt.stroke();</div><div class="line">        /*下半身*/</div><div class="line">        cxt.beginPath();</div><div class="line">        cxt.fillStyle = '#0bb0da';</div><div class="line">        cxt.moveTo(80, 346);</div><div class="line">        //左衣服</div><div class="line">        cxt.lineTo(26, 406);</div><div class="line">        cxt.lineTo(65, 440);</div><div class="line">        cxt.lineTo(85, 418);</div><div class="line">        cxt.lineTo(85, 528);</div><div class="line">        cxt.lineTo(185, 528);</div><div class="line">        //右衣服</div><div class="line">        cxt.lineTo(315, 528);</div><div class="line">        cxt.lineTo(315, 418);</div><div class="line">        cxt.lineTo(337, 440);</div><div class="line">        cxt.lineTo(374, 406);</div><div class="line">        cxt.lineTo(320, 346);</div><div class="line">        cxt.fill();</div><div class="line">        cxt.stroke();</div><div class="line">        /*手*/</div><div class="line">        //左手</div><div class="line">        cxt.beginPath();</div><div class="line">        cxt.fillStyle = '#fff';</div><div class="line">        cxt.arc(37, 433, 30, 0, 2 * Math.PI);</div><div class="line">        cxt.fill();</div><div class="line">        cxt.stroke();</div><div class="line">        //右手</div><div class="line">        cxt.beginPath();</div><div class="line">        cxt.fillStyle = '#fff';</div><div class="line">        cxt.arc(363, 433, 30, 0, 2 * Math.PI);</div><div class="line">        cxt.fill();</div><div class="line">        cxt.stroke();</div><div class="line">        /*肚*/</div><div class="line">        cxt.beginPath();</div><div class="line">        cxt.fillStyle = '#fff';</div><div class="line">        cxt.arc(200, 400, 91, 1.8 * Math.PI, 1.2 * Math.PI);</div><div class="line">        cxt.fill();</div><div class="line">        cxt.stroke();</div><div class="line">        //小口袋</div><div class="line">        cxt.beginPath();</div><div class="line">        cxt.fillStyle = '#fff';</div><div class="line">        cxt.moveTo(130, 394);</div><div class="line">        cxt.lineTo(270, 394);</div><div class="line">        cxt.moveTo(130, 394);</div><div class="line">        cxt.bezierCurveTo(130, 490, 270, 490, 270, 394);</div><div class="line">        cxt.fill();</div><div class="line">        cxt.stroke();</div><div class="line">        /*两只脚的空隙*/</div><div class="line">        cxt.beginPath();</div><div class="line">        cxt.fillStyle = '#fff';</div><div class="line">        cxt.arc(200, 529, 20,Math.PI, 0);</div><div class="line">        cxt.fill();</div><div class="line">        cxt.stroke();</div><div class="line">        /*脚*/</div><div class="line">        //左脚</div><div class="line">        cxt.beginPath();</div><div class="line">        cxt.fillStyle='#fff';</div><div class="line">        cxt.moveTo(180,528);</div><div class="line">        cxt.lineTo(72,528);</div><div class="line">        cxt.bezierCurveTo(52,528,52,558,72,558);</div><div class="line">        cxt.lineTo(180,558);</div><div class="line">        cxt.moveTo(180,558);</div><div class="line">        cxt.bezierCurveTo(200,558,200,528,180,528);</div><div class="line">        cxt.fill();</div><div class="line">        cxt.stroke();</div><div class="line">        //右脚</div><div class="line">        cxt.beginPath();</div><div class="line">        cxt.fillStyle='#fff';</div><div class="line">        cxt.moveTo(220,528);</div><div class="line">        cxt.lineTo(328,528);</div><div class="line">        cxt.bezierCurveTo(348,528,348,558,328,558);</div><div class="line">        cxt.lineTo(220,558);</div><div class="line">        cxt.moveTo(220,558);</div><div class="line">        cxt.bezierCurveTo(200,558,200,528,220,528);</div><div class="line">        cxt.fill();</div><div class="line">        cxt.stroke();</div><div class="line">    &#125;;</div><div class="line">   </div><div class="line">&lt;/script&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> Canvas </tag>
            
            <tag> HTML5 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSS3 圆圈自动扩散效果]]></title>
      <url>/year/05/09/CSS3%E5%9C%86%E5%BD%A2%E6%89%A9%E6%95%A3/</url>
      <content type="html"><![CDATA[<p>前几天学长回学校做毕业设计，刚好自己在找工作，想去他们公司，然后问我会什么，就说你先去我们官网看看能不能写出来吧，看了一眼，就一个特效自己不是很熟，然后自己花了一节课的时间想了下，实现了。<br><a id="more"></a><br><a href="https://codepen.io/jiangxiaolin1995/pen/xdJxGj" target="_blank" rel="external">Demo戳我</a></p>
<p>下面直接上代码。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;~</div><div class="line">&lt;html&gt;</div><div class="line"></div><div class="line">&lt;head&gt;</div><div class="line">  &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;</div><div class="line">  &lt;meta name="viewport" content="width=device-width, initial-scale=1" /&gt;</div><div class="line">  &lt;title&gt;css3 圆形扩散效果&lt;/title&gt;</div><div class="line">  &lt;style&gt;</div><div class="line">    @keyframes big &#123;</div><div class="line">      0% &#123;</div><div class="line">        transform: scale(0.3);</div><div class="line">        -webkit-transform: scale(0.3);</div><div class="line">        opacity: 0.0;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      25% &#123;</div><div class="line">        transform: scale(0.3);</div><div class="line">        -webkit-transform: scale(0.3);</div><div class="line">        opacity: 0.1;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      50% &#123;</div><div class="line">        transform: scale(0.5);</div><div class="line">        -webkit-transform: scale(0.5);</div><div class="line">        opacity: 0.3;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      75% &#123;</div><div class="line">        transform: scale(0.8);</div><div class="line">        -webkit-transform: scale(0.8);</div><div class="line">        opacity: 0.5;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      100% &#123;</div><div class="line">        transform: scale(1);</div><div class="line">        -webkit-transform: scale(1);</div><div class="line">        opacity: 0.0;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @keyframes big1 &#123;</div><div class="line">      0% &#123;</div><div class="line">        transform: scale(0.3);</div><div class="line">        -webkit-transform: scale(0.3);</div><div class="line">        opacity: 0.0;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      25% &#123;</div><div class="line">        transform: scale(0.3);</div><div class="line">        -webkit-transform: scale(0.3);</div><div class="line">        opacity: 0.1;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      50% &#123;</div><div class="line">        transform: scale(0.3);</div><div class="line">        -webkit-transform: scale(0.3);</div><div class="line">        opacity: 0.3;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      75% &#123;</div><div class="line">        transform: scale(0.5);</div><div class="line">        -webkit-transform: scale(0.5);</div><div class="line">        opacity: 0.5;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      100% &#123;</div><div class="line">        transform: scale(0.8);</div><div class="line">        -webkit-transform: scale(0.8);</div><div class="line">        opacity: 0.0;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    .container &#123;</div><div class="line">      position: relative;</div><div class="line">      width: 40px;</div><div class="line">      height: 40px;</div><div class="line">      left: 500px;</div><div class="line">      /*border: 1px solid #000; hovertree.com */</div><div class="line">    &#125;</div><div class="line">    /* 保持大小不变的小圆圈 */</div><div class="line"></div><div class="line">    .round &#123;</div><div class="line">      position: absolute;</div><div class="line">      width: 92px;</div><div class="line">      height: 92px;</div><div class="line">      left: 120px;</div><div class="line">      top: 120px;</div><div class="line">      -webkit-border-radius: 50%;</div><div class="line">      -moz-border-radius: 50%;</div><div class="line">      border: 2px solid green;</div><div class="line">      border-radius: 50%;</div><div class="line">      z-index: 2;</div><div class="line">    &#125;</div><div class="line">    /* 产生动画（向外扩散变大）的圆圈  */</div><div class="line"></div><div class="line">    .round1 &#123;</div><div class="line">      position: absolute;</div><div class="line">      width: 320px;</div><div class="line">      height: 320px;</div><div class="line">      left: 2px;</div><div class="line">      top: 2px;</div><div class="line">      border: 6px solid green;</div><div class="line">      -webkit-border-radius: 50%;</div><div class="line">      -moz-border-radius: 50%;</div><div class="line">      border-radius: 50%;</div><div class="line">      z-index: 1;</div><div class="line">      opacity: 0;</div><div class="line">      -webkit-animation: big 2s ease-out;</div><div class="line">      -moz-animation: big 2s ease-out;</div><div class="line">      animation: big 2s ease-out;</div><div class="line">      -webkit-animation-iteration-count: infinite;</div><div class="line">      -moz-animation-iteration-count: infinite;</div><div class="line">      animation-iteration-count: infinite;</div><div class="line">      box-shadow: 1px 1px 30px green;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    .round2 &#123;</div><div class="line">      position: absolute;</div><div class="line">      width: 320px;</div><div class="line">      height: 320px;</div><div class="line">      left: 2px;</div><div class="line">      top: 2px;</div><div class="line">      border: 6px solid green;</div><div class="line">      -webkit-border-radius: 50%;</div><div class="line">      -moz-border-radius: 50%;</div><div class="line">      border-radius: 50%;</div><div class="line">      z-index: 1;</div><div class="line">      opacity: 0;</div><div class="line">      -webkit-animation: big1 2s ease-out;</div><div class="line">      -moz-animation: big1 2s ease-out;</div><div class="line">      animation: big1 2s ease-out;</div><div class="line">      -webkit-animation-iteration-count: infinite;</div><div class="line">      -moz-animation-iteration-count: infinite;</div><div class="line">      animation-iteration-count: infinite;</div><div class="line">      box-shadow: 1px 1px 30px green;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    </div><div class="line">  &lt;/style&gt;</div><div class="line">&lt;/head&gt;</div><div class="line"></div><div class="line">&lt;body&gt;</div><div class="line">  &lt;div class="container"&gt;</div><div class="line">    &lt;div class="round"&gt;&lt;/div&gt;</div><div class="line">    &lt;div class="round1"&gt;&lt;/div&gt;</div><div class="line">    &lt;div class="round2"&gt;&lt;/div&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">&lt;/body&gt;</div><div class="line"></div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>写完看了下跟网上的思路很像，但有点差距，跟原来的效果也不是很一样，官网第一个圆比较小，自己放大的原因是为了方便改样式，大体还是差不多的，用到的CSS3属性不是很难理解，有不懂得属性可以去查阅。</p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> CSS3 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Next Canvas 背景]]></title>
      <url>/year/03/04/Next%20Canvas%20%E8%83%8C%E6%99%AF/</url>
      <content type="html"><![CDATA[<p>最经发现很多博客主题有很炫酷的Canvas效果，查了一下，最新的NexT主题支持一个叫<code>canvas-nest</code>效果的背景特效，接下来教大家如何配置。<br><a id="more"></a></p>
<h3 id="修改-layout-swig"><a href="#修改-layout-swig" class="headerlink" title="修改_layout.swig"></a>修改<code>_layout.swig</code></h3><p>打开 <code>next/layout/_layout.swig</code><br><strong>在 &lt; /body&gt;之前添加代码(注意不要放在&lt; /head&gt;的后面)</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;% <span class="keyword">if</span> theme.canvas_nest %&#125;</div><div class="line">  &lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"</span>&gt;&lt;/script&gt;</div><div class="line">  &#123;% endif %&#125;</div></pre></td></tr></table></figure></p>
<h3 id="接下来修改修改配置文件"><a href="#接下来修改修改配置文件" class="headerlink" title="接下来修改修改配置文件"></a>接下来修改修改配置文件</h3><p>打开 <code>/next/_config.yml</code>,在里面添加如下代码(可以放在最后面)<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># --------------------------------------------------------------</div><div class="line"># background settings</div><div class="line"># --------------------------------------------------------------</div><div class="line"># add canvas-nest effect</div><div class="line"># see detail from https://github.com/hustcc/canvas-nest.js</div><div class="line">canvas_nest: true</div></pre></td></tr></table></figure></p>
<p>到此就结束了，运行 <code>hexo clean</code>，然后运行 <code>hexo g</code>,然后运行 <code>hexo s</code>，最后打开浏览器在浏览器的地址栏输入 <code>localhost:4000</code> 就能看到效果了\（￣︶￣）/</p>
<h3 id="修改Canvas样式"><a href="#修改Canvas样式" class="headerlink" title="修改Canvas样式"></a>修改Canvas样式</h3><p>把上一步在 <code>_layout.swig</code>中添加的代码改为：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;% <span class="keyword">if</span> theme.canvas_nest %&#125;</div><div class="line">&lt;script type=<span class="string">"text/javascript"</span></div><div class="line">color=<span class="string">"0,0,255"</span> opacity=<span class="string">'0.7'</span> zIndex=<span class="string">"-2"</span> count=<span class="string">"99"</span> src=<span class="string">"//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"</span>&gt;&lt;/script&gt;</div><div class="line">&#123;% endif %&#125;</div></pre></td></tr></table></figure></p>
<h4 id="配置项说明"><a href="#配置项说明" class="headerlink" title="配置项说明"></a>配置项说明</h4><ul>
<li>color ：线条颜色, 默认: ‘0,0,0’；三个数字分别为(R,G,B)</li>
<li>opacity: 线条透明度（0~1）, 默认: 0.5</li>
<li>count: 线条的总数量, 默认: 150</li>
<li>zIndex: 背景的z-index属性，css属性用于控制所在层的位置, 默认: -1</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> NexT </tag>
            
            <tag> Canvas </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Gulp 练习]]></title>
      <url>/year/12/13/Gulp%E7%BB%83%E4%B9%A0/</url>
      <content type="html"><![CDATA[<p>一个简单地<code>gulp</code>练习，过几天写一个<code>gulp</code> API讲解<br><a id="more"></a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</div><div class="line"><span class="keyword">var</span> compass = <span class="built_in">require</span>(<span class="string">'gulp-compass'</span>);</div><div class="line"><span class="keyword">var</span> sass = <span class="built_in">require</span>(<span class="string">'gulp-sass'</span>);</div><div class="line"><span class="keyword">var</span> connect = <span class="built_in">require</span>(<span class="string">'gulp-connect'</span>);</div><div class="line"><span class="keyword">var</span> concat = <span class="built_in">require</span>(<span class="string">'gulp-concat'</span>);</div><div class="line"><span class="keyword">var</span> uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>);</div><div class="line"><span class="keyword">var</span> rename = <span class="built_in">require</span>(<span class="string">'gulp-rename'</span>);</div><div class="line"><span class="keyword">var</span> minifyCSS= <span class="built_in">require</span>(<span class="string">'gulp-minify-css'</span>);</div><div class="line"><span class="keyword">var</span> imagemin= <span class="built_in">require</span>(<span class="string">'gulp-imagemin'</span>);</div><div class="line"></div><div class="line"><span class="comment">/*var gulp = require("gulp");//把gulp模块包含进去</span></div><div class="line">//gulp.task()任务 两个参数  第一个名字 第二个要做的事情</div><div class="line">gulp.task('hello',function()&#123;</div><div class="line">  console.log('您好');</div><div class="line">&#125;);*/</div><div class="line"></div><div class="line"><span class="comment">//gulp.task('default', ['hello']);//第二个参数为，默认要执行的任务的列表</span></div><div class="line"></div><div class="line"><span class="comment">//gulp主要的功能  读取想要处理的文件 然后放到想要放的地方去</span></div><div class="line"><span class="comment">//gulp.src() 找出想要处理的文件</span></div><div class="line"><span class="comment">//通过.pipe()处理这些找出来的文件 pipe可以理解成管道 在每个管道中可以去指定他的功能，去处理这个文件</span></div><div class="line"><span class="comment">//.pipe(gulp.dest())  把处理好的文件放到指定的地方</span></div><div class="line"></div><div class="line"><span class="comment">//怎样使用gulp把一个文件复制到另一个文件中</span></div><div class="line"><span class="comment">// var gulp = require('gulp');</span></div><div class="line">gulp.task(<span class="string">'copy-index'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="comment">//大部分gulp的任务就是去读取要处理的文件 读取时 src()</span></div><div class="line">  <span class="keyword">return</span> gulp.src(<span class="string">'index.html'</span>).pipe(gulp.dest(<span class="string">'dist'</span>));</div><div class="line">&#125;);</div><div class="line"><span class="comment">//gulp.task('default', ['copy-index']);</span></div><div class="line"></div><div class="line">gulp.task(<span class="string">'images'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="comment">// return gulp.src('images/*.jpg').pipe(gulp.dest('dist/images'));  </span></div><div class="line">  <span class="comment">//images/*.jpg 意思是images文件夹下的所有名字的jpg格式的文件</span></div><div class="line">  <span class="comment">// return gulp.src('images/*.&#123;jpg,png&#125;').pipe(gulp.dest('dist/images'));  </span></div><div class="line">  <span class="comment">//&#123;&#125;里面可以指定多个扩展名 用，隔开注意，后面不能有空格</span></div><div class="line">  <span class="comment">// return gulp.src('images/*').pipe(gulp.dest('dist/images'));  </span></div><div class="line">  <span class="comment">//images/*是images下的所有文件 但不包括文件下的文件</span></div><div class="line">  <span class="comment">// return gulp.src('images/*/*').pipe(gulp.dest('dist/images'));  </span></div><div class="line">  <span class="comment">//images/*/*意识是images里面的所有东西包含images里面二级页面所有的东西</span></div><div class="line">  <span class="keyword">return</span> gulp.src(<span class="string">'images/**/*'</span>)</div><div class="line">    .pipe(imagemin())</div><div class="line">    .pipe(gulp.dest(<span class="string">'dist/images'</span>));  </div><div class="line">&#125;);</div><div class="line"><span class="comment">//运行多个gulp，可以用一个数组，数组里的每一个项目就是用来匹配文件的gulp</span></div><div class="line"><span class="comment">// gulp.task('data', function()&#123;</span></div><div class="line"><span class="comment">//   return gulp.src(['xml/*.xm','json/*.json']).pipe(gulp.dest('dist/data'));</span></div><div class="line"><span class="comment">// &#125;);</span></div><div class="line"><span class="comment">//经常把文件包含到要处理的文件列表里面，在这些列表里面可能有一些特定的文件而你又不想包含进来，在这些列表里面创建一个gulp可以描述一些要排除的文件，在前面加一个！即可</span></div><div class="line">gulp.task(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> gulp.src([<span class="string">'xml/*.xm'</span>,<span class="string">'json/*.json'</span>,<span class="string">'!json/secret-*.json'</span>]).pipe(gulp.dest(<span class="string">'dist/data'</span>));</div><div class="line">&#125;);</div><div class="line"><span class="comment">//在创建gulp的时候可以创建gulp依赖的其他任务</span></div><div class="line"><span class="comment">//创建一个任务build 依赖与上面三个任务 执行的时候是会先执行依赖的任务，然后在执行他要做的事 执行依赖的任务会同时执行，而不是依次执行</span></div><div class="line"><span class="comment">// gulp.task('build',['copy-index','images','data'],function()&#123;</span></div><div class="line">  <span class="comment">// console.log('编译成功');</span></div><div class="line"><span class="comment">// &#125;);</span></div><div class="line"><span class="comment">//gulp.watch()可以用来监视一些文件，当这些文件发生一些变化的时候，就会立即去执行一些任务</span></div><div class="line">gulp.task(<span class="string">'watch'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  gulp.watch(<span class="string">'index.html'</span>,[<span class="string">'copy-index'</span>]);<span class="comment">//第二个参数必须是数组 意思是当index.html发生变化的时候执行copy-index任务</span></div><div class="line">  gulp.watch(<span class="string">'images/**/*'</span>,[<span class="string">'images'</span>]);</div><div class="line">  gulp.watch(<span class="string">'xml/*.xm'</span>,<span class="string">'json/*.json'</span>,<span class="string">'!json/secret-*.json'</span>,[<span class="string">'data'</span>]);</div><div class="line">&#125;);</div><div class="line"><span class="comment">//gulp提供了一些很好的接口，但是它本身并不会去做太多的事情，除了可以去读取文件，去监视文件的变化，可以把文件放到指定的位置，我们可以使用插件去扩展gulp的功能</span></div><div class="line"></div><div class="line"></div><div class="line">gulp.task(<span class="string">'sass'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> gulp.src(<span class="string">'stylesheets/**/*.scss'</span>)</div><div class="line">    .pipe(sass())</div><div class="line">    .pipe(minifyCSS()) <span class="comment">//最小化css gulp-minify-css</span></div><div class="line">    .pipe(gulp.dest(<span class="string">'dist/css'</span>));</div><div class="line"></div><div class="line">&#125;);</div><div class="line"><span class="comment">//gulp-connect 创建本地服务器</span></div><div class="line">gulp.task(<span class="string">'server'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  connect.server(&#123;</div><div class="line">    <span class="attr">root</span>:<span class="string">'dist'</span>,</div><div class="line">    <span class="attr">livereload</span>:<span class="literal">true</span> <span class="comment">//启用实时刷新</span></div><div class="line">  &#125;);</div><div class="line">&#125;);</div><div class="line"><span class="comment">//实时刷新浏览器</span></div><div class="line">gulp.task(<span class="string">'copy-index'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="comment">//大部分gulp的任务就是去读取要处理的文件 读取时 src()</span></div><div class="line">  <span class="keyword">return</span> gulp.src(<span class="string">'index.html'</span>)</div><div class="line">    .pipe(gulp.dest(<span class="string">'dist'</span>))</div><div class="line">    .pipe(connect.reload());</div><div class="line">&#125;);</div><div class="line">gulp.task(<span class="string">'default'</span>,[<span class="string">'server'</span>,<span class="string">'watch'</span>]);</div><div class="line"><span class="comment">//gulp-concat 可以把一些文件合并到一起</span></div><div class="line">gulp.task(<span class="string">'scripts'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> gulp.src([<span class="string">'javascript/index.js'</span>,<span class="string">'javascript/supersized.3.2.7.min.js'</span>])</div><div class="line">    .pipe(concat(<span class="string">'vendor.js'</span>))</div><div class="line">    .pipe(gulp.dest(<span class="string">'dist/js'</span>))</div><div class="line">    .pipe(uglify()) <span class="comment">//gulp-uglify压缩js文件</span></div><div class="line">    .pipe(rename(<span class="string">'vendor.min.js'</span>))</div><div class="line">    .pipe(gulp.dest(<span class="string">'dist/js'</span>));</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">//在把处理好的文件存储在指定的位置之前，我们可以对其重命名 gulp-rename</span></div><div class="line"><span class="comment">//优化图像体积</span></div><div class="line"></div><div class="line">gulp.task(<span class="string">'hello'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'hello world'</span>)</div><div class="line">&#125;)</div><div class="line">gulp.task(<span class="function"><span class="keyword">function</span>)</span></div></pre></td></tr></table></figure></p>
]]></content>
      
        
        <tags>
            
            <tag> Gulp </tag>
            
            <tag> 自动化 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[从倒影说起，谈谈 CSS 继承 inherit]]></title>
      <url>/year/11/29/-webkit-box-reflect/</url>
      <content type="html"><![CDATA[<p>给定一张有如下背景图的 div：<br><img src="http://i2.muimg.com/594295/e5f600ba64c0c174.jpg" alt="咖啡猫"><br>制作如下的倒影效果：<br><img src="http://i2.muimg.com/594295/ad48407c22907374.png" alt="咖啡猫倒影效果"><br><a id="more"></a><br>方法很多，但是我们当然要寻找最快最便捷的方法，至少得是无论图片怎么变化，<code>div</code> 大小怎么变化，我们都不用去改我们的代码。</p>
<h4 id="法一：-webkit-box-reflect"><a href="#法一：-webkit-box-reflect" class="headerlink" title="法一：-webkit-box-reflect"></a>法一：-webkit-box-reflect</h4><p>这是一个十分新的 <strong>CSS</strong> 属性，使用起来十分简单，可以从各个方向反射我们内容。不过兼容性过于惨淡：</p>
<blockquote>
<p>基本上是只有 -webkit- 内核的浏览器才支持。<br><img src="http://i2.muimg.com/594295/601275f18b708057.png" alt="Markdown"><br>不过使用起来真的是方便，解决方法如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">div</span>&#123;</div><div class="line">    <span class="attribute">-webkit-box-reflect</span>: below;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<p><a href="https://codepen.io/jiangxiaolin1995/pen/bWMPEB" target="_blank" rel="external">-webkit- 内核下查看Demo</a><br><code>box-reflect</code> 有四个方向可以选，<code>below | above | left | right</code> 代表下上左右。</p>
<h4 id="法二：inherit，使用继承"><a href="#法二：inherit，使用继承" class="headerlink" title="法二：inherit，使用继承"></a>法二：inherit，使用继承</h4><p>主要还是为了介绍这种方法，兼容性好。<br><code>inherit</code> 是啥，每个 CSS 属性定义的概述都指出了这个属性是默认继承的 (“Inherited: Yes”) 还是默认不继承的 (“Inherited: no”)。这决定了当你没有为元素的属性指定值时该如何计算值。</p>
<p>灵活使用 <code>inherit</code> 继承父值，可以解决许多看似复杂的问题。对于本题，我们对图片容器添加一个伪元素，使用 <code>background-image:inherit</code> 继承父值的背景图值，就可以做到<br>无论图片如何变，我们的 CSS 代码都无需改动：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">div::after &#123;</div><div class="line">    content: "";</div><div class="line">    position: absolute;</div><div class="line">    top: 100%;</div><div class="line">    left: 0;</div><div class="line">    right: 0;</div><div class="line">    bottom: -100%;</div><div class="line">    background-image: inherit;</div><div class="line">    transform: rotateX(180deg);;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><a href="https://codepen.io/jiangxiaolin1995/pen/qmYzdL" target="_blank" rel="external">Demo戳我</a>。<br>我们使用伪元素 <code>background-image: inherit;</code> 继承父元素的背景图，再使用 <code>transform</code> 旋转容器达到反射的效果。</p>
<p>说到底，CSS 属性的取值就是由默认值（initial），继承（inherit）与加权系统构成的（其实还有 unset(未设置)、revert(还原)），厘清它们的关系及使用方法对熟练使用 CSS 大有裨益。</p>
<blockquote>
<p>灵感全来于一个<strong>github</strong>项目，不是为了让大家用生僻的<strong>CSS</strong>属性解决需求，在项目中法一完全够用，就是为了大家熟悉<strong>CSS</strong>属性。<br><a href="https://github.com/chokcoco/iCSS" target="_blank" rel="external">github项目地址</a>（感谢<strong>chococo</strong>为维护这个项目付出的努力</p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> CSS </tag>
            
            <tag> inherit </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Zepto源码]]></title>
      <url>/year/11/14/Zepto%E6%BA%90%E7%A0%81/</url>
      <content type="html"><![CDATA[<p><strong> 首先是pc和移动端点击事件的兼容</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> UA = <span class="built_in">window</span>.navigator,userAgent; </div><div class="line"><span class="keyword">var</span> CLICK = <span class="string">'click'</span>;</div><div class="line"><span class="keyword">if</span>(<span class="regexp">/ipad | iphone | android/</span>.test(UA))&#123;</div><div class="line">CLICK = <span class="string">'tap'</span> ;</div><div class="line">&#125;</div><div class="line">对象[ CLICK ]  (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)</div></pre></td></tr></table></figure>
<a id="more"></a>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> Zepto = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)()<span class="comment">// 定义一个全局变量 防止变量被污染 使得 函数内部变量不会污染外边的变量 闭包</span></div><div class="line"><span class="built_in">window</span>.Zepto = Zepto;  <span class="comment">// 把 Zepto 赋值给 window 任何情况下可以直接调用</span></div><div class="line"><span class="built_in">window</span>.$ === undefind &amp;&amp; (<span class="built_in">window</span>.$ = Zepto)</div></pre></td></tr></table></figure>
<p><strong> 简单的Zepto结构可以简单地写成如下代码</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Zepto = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> $;</div><div class="line">  <span class="comment">// 此处省去N行代码···</span></div><div class="line">  $ = <span class="function"><span class="keyword">function</span>(<span class="params">selector, context</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> zepto.init(selector, context)</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 此处省去N行代码··</span></div><div class="line"> <span class="keyword">return</span> $; 把返回的 $ 赋值给 Zepto 变量</div><div class="line">&#125;)() <span class="comment">// 定义自执行函数</span></div><div class="line"><span class="comment">// 把返回的 $ 赋值给 window</span></div><div class="line"><span class="built_in">window</span>.Zepto = Zepto;  <span class="comment">// 把返回的 $ 赋值给 Zepto 变量  然后把 Zepto 赋值给 window </span></div><div class="line"><span class="built_in">window</span>.$ === undefind &amp;&amp; (<span class="built_in">window</span>.$ = Zepto)</div></pre></td></tr></table></figure></p>
<h3 id="分析函数"><a href="#分析函数" class="headerlink" title="分析函数"></a>分析函数</h3><p>  这里我们可以看到我们平时使用的 <em> $(‘p’) </em> 使用 Zepto 的时候会顺藤摸瓜找到  </p>
<ul>
<li>$= function(selector, context) <em> 而这个 </em> p <em> 选择器也会传递给 </em> selector * 参数<h4 id="那么-init-函数是干嘛的呢"><a href="#那么-init-函数是干嘛的呢" class="headerlink" title="那么 init 函数是干嘛的呢"></a>那么 <em>init</em> 函数是干嘛的呢</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Zepto = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> $，Zepto = &#123;&#125;; <span class="comment">// Zepto 与 zepto 不一样 </span></div><div class="line">    <span class="comment">// 此处省去N行代码···</span></div><div class="line">  zepto.init = <span class="function"><span class="keyword">function</span>(<span class="params">selector, context</span>)</span>&#123;</div><div class="line">	<span class="comment">// 函数内容</span></div><div class="line">	<span class="keyword">return</span> zepto.Z(dom, selector);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 此处省去N行代码···</span></div><div class="line">  $ = <span class="function"><span class="keyword">function</span>(<span class="params">selector, context</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> zepto.init(selector, context)</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 此处省去N行代码··</span></div><div class="line"> <span class="keyword">return</span> $; 把返回的 $ 赋值给 Zepto 变量</div><div class="line">&#125;)() <span class="comment">// 定义自执行函数</span></div><div class="line"><span class="comment">// 把返回的 $ 赋值给 window</span></div><div class="line"><span class="built_in">window</span>.Zepto = Zepto;  <span class="comment">// 把返回的 $ 赋值给 Zepto 变量  然后把 Zepto 赋值给 window </span></div><div class="line"><span class="built_in">window</span>.$ === undefind &amp;&amp; (<span class="built_in">window</span>.$ = Zepto);</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="zepto-init-函数"><a href="#zepto-init-函数" class="headerlink" title="zepto.init 函数"></a><code>zepto.init</code> 函数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> zepto.init = <span class="function"><span class="keyword">function</span>(<span class="params">selector, context</span>)</span>&#123;</div><div class="line"> <span class="keyword">var</span> dom;</div><div class="line"><span class="comment">// 此处省去N行代码···</span></div><div class="line"> <span class="keyword">return</span> zepto.Z(dom, selector);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>中间省略的代码都是根据不同条件对 <code>dom</code> 变量进行赋值。 <code>dom</code>从名字也可以猜测出来，它将会赋值一个或多个 <strong>DOM</strong> 节点。最终，它通过 <code>selector</code>一起传递给  <em>zepto.Z</em> 函数并返回值 </p>
<p>先忽略<code>zepto.Z</code>是什么鬼，先忽略里面的代码<code>init</code> 函数中间的代码是用来干嘛的呢</p>
<ul>
<li>无参数，即 <code>$()</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>( !selectot ) <span class="keyword">return</span> zeto.Z()</div><div class="line"><span class="string">``</span><span class="string">`  </span></div><div class="line"> 如果没有参数，将返回一个空的 `zepto<span class="string">`集合，然后交给`</span>zepto.Z<span class="string">`来处理</span></div><div class="line">- selector 参数是字符串，例如 `$(<span class="string">'p'</span>)<span class="string">` `</span>$(<span class="string">'&lt;div&gt;'</span>)<span class="string">`  `</span>$(<span class="string">'#content'</span>)<span class="string">`  等等</span></div><div class="line"></div><div class="line">`<span class="string">``</span>javascript</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> selector == <span class="string">'string'</span>) &#123;  <span class="comment">// 参数是字符串 $('p')</span></div><div class="line">      selector = selector.trim()</div><div class="line">      <span class="comment">// If it's a html fragment, create nodes from it</span></div><div class="line">      <span class="comment">// Note: In both Chrome 21 and Firefox 15, DOM error 12</span></div><div class="line">      <span class="comment">// is thrown if the fragment doesn't begin with &lt;</span></div><div class="line">      <span class="keyword">if</span> (selector[<span class="number">0</span>] == <span class="string">'&lt;'</span> &amp;&amp; fragmentRE.test(selector))</div><div class="line">        dom = zepto.fragment(selector, <span class="built_in">RegExp</span>.$<span class="number">1</span>, context), selector = <span class="literal">null</span></div><div class="line">      <span class="comment">// If there's a context, create a collection on that context first, and select</span></div><div class="line">      <span class="comment">// nodes from there</span></div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (context !== <span class="literal">undefined</span>) <span class="keyword">return</span> $(context).find(selector)</div><div class="line">      <span class="comment">// If it's a CSS selector, use it to select nodes.</span></div><div class="line">      <span class="keyword">else</span> dom = zepto.qsa(<span class="built_in">document</span>, selector)</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>上面代码，如果 <code>selector</code> 是字符串，接下来会有三种情况。</p>
<ul>
<li>情况1，参数为 <code>&lt;div&gt;</code> 这种形式，即是一个 <code>html</code> 标签的，那么<code>dom</code> 变量会被赋值为用这个标签创建的DOM对象，就像 <code>dom = document.createElement(&#39;div&#39;)</code> 差不多。其中涉及到了<code>fragmentRE</code>和<code>zepto.fragment</code>两个我们尚未了解的东东，此处不要深究，知道这段代码的意思即可。</li>
</ul>
<p>注意，通过测试发现，这里给dom赋值的其实不是一个dom节点对象，而是被封装称了数组。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// If it's a html fragment, create nodes from it</span></div><div class="line"><span class="comment">// Note: In both Chrome 21 and Firefox 15, DOM error 12</span></div><div class="line"><span class="comment">// is thrown if the fragment doesn't begin with &lt;</span></div><div class="line"><span class="keyword">if</span> (selector[<span class="number">0</span>] == <span class="string">'&lt;'</span> &amp;&amp; fragmentRE.test(selector))</div><div class="line">  dom = zepto.fragment(selector, <span class="built_in">RegExp</span>.$<span class="number">1</span>, context), selector = <span class="literal">null</span></div></pre></td></tr></table></figure></p>
<ul>
<li><p>情况2，如果第二个参数有值，则先根据第二个参数生成<code>zepto</code>对象，然后再调用<code>.find</code>来获取，例如<code>$(&#39;.item&#39;, &#39;#content&#39;)</code>这种用法。<code>find</code>方法是<code>zepto</code>对象的一个函数，API中用法的介绍。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// If there's a context, create a collection on that context first, and select</span></div><div class="line"><span class="comment">// nodes from there</span></div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (context !== <span class="literal">undefined</span>) <span class="keyword">return</span> $(context).find(selector)</div></pre></td></tr></table></figure>
</li>
<li><p>情况3，以上两种情况都不是，则调用<code>zepto.qsa</code>来获取数据，后来聊这个方法的具体实现。<code>qsa</code>即<code>querySelectAll</code>的缩写，看名字能大体明白了吧？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">      <span class="comment">// If it's a CSS selector, use it to select nodes.</span></div><div class="line">      <span class="keyword">else</span> dom = zepto.qsa(<span class="built_in">document</span>, selector)</div><div class="line">selector参数是函数，例如$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;)</div><div class="line">    <span class="comment">// If a function is given, call it when the DOM is ready</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (isFunction(selector)) <span class="keyword">return</span> $(<span class="built_in">document</span>).ready(selector)</div></pre></td></tr></table></figure>
</li>
</ul>
<p>这种用法也比较常见，意思是待<code>dom</code>加载完毕再执行函数。这个<code>ready</code>函数的具体实现后面会讲到，这里先知道意思即可。</p>
<p><code>selector</code>本身就是个<code>zepto</code>对象<br>这种用法比较少，但是也不能避免，例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = $(<span class="string">'p'</span>);</div><div class="line">$(a);  <span class="comment">// 这里传入的 a 本身就是个 zepto 对象了。</span></div></pre></td></tr></table></figure></p>
<p>源码中使用<code>zepto.isZ</code>来判断，如果是的话，直接就返回自身。<code>zepto.isZ</code>的实现很简单，看源码即可。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// If a Zepto collection is given, just return it</span></div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (zepto.isZ(selector)) <span class="keyword">return</span> selector</div></pre></td></tr></table></figure></p>
<p>其他情况<br>当以上情况都不符合的时候，即<code>selector</code>参数既不是空、也不是字符串、也不是函数的时候。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">  <span class="comment">// normalize array if an array of nodes is given</span></div><div class="line">  <span class="keyword">if</span> (isArray(selector)) dom = compact(selector)</div><div class="line">  <span class="comment">// Wrap DOM nodes.</span></div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (isObject(selector))</div><div class="line">    dom = [selector], selector = <span class="literal">null</span></div><div class="line">  <span class="comment">// If it's a html fragment, create nodes from it</span></div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (fragmentRE.test(selector))</div><div class="line">    dom = zepto.fragment(selector.trim(), <span class="built_in">RegExp</span>.$<span class="number">1</span>, context), selector = <span class="literal">null</span></div><div class="line">  <span class="comment">// If there's a context, create a collection on that context first, and select</span></div><div class="line">  <span class="comment">// nodes from there</span></div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (context !== <span class="literal">undefined</span>) <span class="keyword">return</span> $(context).find(selector)</div><div class="line">  <span class="comment">// And last but no least, if it's a CSS selector, use it to select nodes.</span></div><div class="line">  <span class="keyword">else</span> dom = zepto.qsa(<span class="built_in">document</span>, selector)</div></pre></td></tr></table></figure></p>
<ul>
<li><p>情况1，<code>selector</code>参数是数组，则通过一个<code>compact</code>处理一下赋值给dom。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// normalize array if an array of nodes is given</span></div><div class="line"><span class="keyword">if</span> (isArray(selector)) dom = compact(selector)</div></pre></td></tr></table></figure>
</li>
<li><p>情况2，<code>selector</code>参数是DOM节点，则将它作为数组赋值给dom。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Wrap DOM nodes.</span></div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (isObject(selector))</div><div class="line">  dom = [selector], selector = <span class="literal">null</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>剩余情况，其实在<code>selector</code>是字符串的时候就已经考虑到了，因此感觉这里多余了。不过也可能是我考虑不周到，有疏漏的地方，如果谁发现了还望不吝赐教。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// If it's a html fragment, create nodes from it</span></div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (fragmentRE.test(selector))</div><div class="line">  dom = zepto.fragment(selector.trim(), <span class="built_in">RegExp</span>.$<span class="number">1</span>, context), selector = <span class="literal">null</span></div><div class="line"><span class="comment">// If there's a context, create a collection on that context first, and select</span></div><div class="line"><span class="comment">// nodes from there</span></div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (context !== <span class="literal">undefined</span>) <span class="keyword">return</span> $(context).find(selector)</div><div class="line"><span class="comment">// And last but no least, if it's a CSS selector, use it to select nodes.</span></div><div class="line"><span class="keyword">else</span> dom = zepto.qsa(<span class="built_in">document</span>, selector)</div></pre></td></tr></table></figure></p>
<p>这里请注意，虽然有些处理函数这一节没有详细看代码实现，但是最终，赋值给<code>dom</code>的形式是一个数组。就像这段代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Wrap DOM nodes.</span></div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (isObject(selector))</div><div class="line">  dom = [selector], selector = <span class="literal">null</span></div></pre></td></tr></table></figure></p>
<p>可以针对不同情况的<code>selector</code>，跟踪代码看一下。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><code>zepto.init</code>函数算是 <code>zepto</code>源码中比较复杂的一个函数，一开篇就遇到了个硬骨头。不过我们这里暂且先把那些分叉放在一边，先把大路疏通，然后在慢慢的去一个一个攻破那些分叉。</p>
<p>接下来我们再把init函数的结构梳理一下。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">zepto.init = <span class="function"><span class="keyword">function</span>(<span class="params">selector, context</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> dom</div><div class="line"></div><div class="line">    <span class="comment">// 分情况对dom赋值：</span></div><div class="line">    <span class="comment">// 1. selector 为空</span></div><div class="line">    <span class="comment">// 2. selector 是字符串，其中又分好几种情况</span></div><div class="line">    <span class="comment">// 3. selector 是函数</span></div><div class="line">    <span class="comment">// 4. 其他情况，例如 selector 是数组、对象等</span></div><div class="line"></div><div class="line">    <span class="comment">// create a new Zepto collection from the nodes found</span></div><div class="line">    <span class="keyword">return</span> zepto.Z(dom, selector)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="zepto-Z-函数"><a href="#zepto-Z-函数" class="headerlink" title="zepto.Z 函数"></a>zepto.Z 函数</h3><p>上一节了解到<code>zepto.init</code>函数中，最终又将数据传递给了<code>zepto.Z</code>函数。这个函数其实非常简单，如果你看不懂，可能是忘记之前讲过的原型链的知识了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// `$.zepto.Z` swaps out the prototype of the given `dom` array</span></div><div class="line"><span class="comment">// of nodes with `$.fn` and thus supplying all the Zepto functions</span></div><div class="line"><span class="comment">// to the array. Note that `__proto__` is not supported on Internet</span></div><div class="line"><span class="comment">// Explorer. This method can be overriden in plugins.</span></div><div class="line">zepto.Z = <span class="function"><span class="keyword">function</span>(<span class="params">dom, selector</span>) </span>&#123;</div><div class="line">  dom = dom || []</div><div class="line">  dom.__proto__ = $.fn</div><div class="line">  dom.selector = selector || <span class="string">''</span></div><div class="line">  <span class="keyword">return</span> dom</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以上代码中，<code>dom</code>是一个数组，并且把它的隐式原型赋值<code>$.fn</code>，而这里的<code>$.fn</code>其实就是一个普通的js对象（马上要说），跟我们之前讲述js原型链的时候一模一样。</p>
<blockquote>
<p>PS：后来发现，最新的zepto.Z实现上目前不一样，到最后再给大家聊聊这事儿。不过这丝毫不影响其他代码的讲解，请放心</p>
</blockquote>
<h4 id="fn是个什么鬼？"><a href="#fn是个什么鬼？" class="headerlink" title="$.fn是个什么鬼？"></a><code>$.fn</code>是个什么鬼？</h4><p>我们在之前的章节说过，$是一个函数，即<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ = <span class="function"><span class="keyword">function</span>(<span class="params">selector, context</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> zepto.init(selector, context)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>而函数也像对象一样，可以随便定义属性赋值的。之前我们说过，每个函数都会有一个内置的<code>prototype</code>属性，这是内置的，我们完全可以自定义一个属性，这个完全可以的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$.fn = &#123;</div><div class="line">    <span class="attr">a</span>: <span class="number">100</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>而<code>zepto</code>源码中，<code>$.fn</code>是这样赋值的，可以去源码中挨个看看其中的属性。</p>
<h4 id="zepto-Z-函数更新"><a href="#zepto-Z-函数更新" class="headerlink" title="zepto.Z 函数更新"></a>zepto.Z 函数更新</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Z</span>(<span class="params">dom, selector</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> i, len = dom ? dom.length : <span class="number">0</span></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) <span class="keyword">this</span>[i] = dom[i]</div><div class="line">    <span class="keyword">this</span>.length = len</div><div class="line">    <span class="keyword">this</span>.selector = selector || <span class="string">''</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// `$.zepto.Z` swaps out the prototype of the given `dom` array</span></div><div class="line">  <span class="comment">// of nodes with `$.fn` and thus supplying all the Zepto functions</span></div><div class="line">  <span class="comment">// to the array. This method can be overridden in plugins.</span></div><div class="line">  zepto.Z = <span class="function"><span class="keyword">function</span>(<span class="params">dom, selector</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Z(dom, selector)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  $.fn = &#123;</div><div class="line">    <span class="comment">// ...很多属性...</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  zepto.Z.prototype = Z.prototype = $.fn</div></pre></td></tr></table></figure>
<p>再把之前的拿出来对比一下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// `$.zepto.Z` swaps out the prototype of the given `dom` array</span></div><div class="line"><span class="comment">// of nodes with `$.fn` and thus supplying all the Zepto functions</span></div><div class="line"><span class="comment">// to the array. Note that `__proto__` is not supported on Internet</span></div><div class="line"><span class="comment">// Explorer. This method can be overriden in plugins.</span></div><div class="line">zepto.Z = <span class="function"><span class="keyword">function</span>(<span class="params">dom, selector</span>) </span>&#123;</div><div class="line">  dom = dom || []</div><div class="line">  dom.__proto__ = $.fn</div><div class="line">  dom.selector = selector || <span class="string">''</span></div><div class="line">  <span class="keyword">return</span> dom</div><div class="line">&#125;</div><div class="line"></div><div class="line">$.fn = &#123;</div><div class="line">  <span class="comment">// ...很多属性...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="两者的异同"><a href="#两者的异同" class="headerlink" title="两者的异同"></a>两者的异同</h4><p>第二种实现方式我们已经讲完了，最终它返回的一个数组，并且强制将<code>__proto__</code>修改为<code>$.fn</code>这个对象。这个修改发生在对象上，修改的隐式原型。<br><img src="http://i2.muimg.com/594295/b08e47a713dc485d.png" alt="Markdown"></p>
<p>而第一种实现方式，是直接将构造函数的原型修改了，即 <code>Z.prototype = $.fn</code>，经过这样一改，构造函数再new出来的对象的隐式原型<code>__proto__</code>自然就指向了<code>$.fn</code>。</p>
<p><img src="http://i2.muimg.com/594295/6edcf43d14a10dc1.png" alt="Markdown"></p>
<p>另外，第一种方式返回的是一个对象数组，而第二种返回的是一个数组。何谓对象数组？——即可以模拟进行数组操作的对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> objArray = &#123;</div><div class="line">    <span class="number">0</span>: <span class="string">'abc'</span>,</div><div class="line">    <span class="number">1</span>: <span class="string">'bcd'</span>,</div><div class="line">    <span class="number">2</span>: <span class="string">'cde'</span>,</div><div class="line">    <span class="attr">length</span>: <span class="number">3</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log( objArray[<span class="number">1</span>] )</div><div class="line"><span class="built_in">console</span>.log( objArray.length )</div></pre></td></tr></table></figure></p>
<p>那为何不用数组，而用对象数组？——对象本质上更加灵活、直观，例如</p>
<p><code>objArray.selector = &#39;&#39;;</code></p>
<h3 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h3><p><img src="http://i2.muimg.com/594295/b08e47a713dc485d.png" alt="Markdown"><br>把整个<code>Zepto</code>对象初始化一下。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Zepto = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> $,</div><div class="line">        zepto = &#123;&#125;</div><div class="line"></div><div class="line">    <span class="comment">// ...省略N行代码...</span></div><div class="line"></div><div class="line">    zepto.Z = <span class="function"><span class="keyword">function</span>(<span class="params">dom, selector</span>) </span>&#123;</div><div class="line">      dom = dom || []</div><div class="line">      dom.__proto__ = $.fn</div><div class="line">      dom.selector = selector || <span class="string">''</span></div><div class="line">      <span class="keyword">return</span> dom</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    zepto.init = <span class="function"><span class="keyword">function</span>(<span class="params">selector, context</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> dom</div><div class="line"></div><div class="line">        <span class="comment">// 针对参数情况，分别对dom赋值</span></div><div class="line"></div><div class="line">        <span class="comment">// 最终调用 zepto.Z 返回的数据</span></div><div class="line">        <span class="keyword">return</span> zepto.Z(dom, selector)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    $ = <span class="function"><span class="keyword">function</span>(<span class="params">selector, context</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> zepto.init(selector, context)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    $.fn = &#123;</div><div class="line">        <span class="comment">// 里面有若干个工具函数</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ...省略N行代码...</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> $</div><div class="line">&#125;)()</div><div class="line"></div><div class="line"><span class="built_in">window</span>.Zepto = Zepto</div><div class="line"><span class="built_in">window</span>.$ === <span class="literal">undefined</span> &amp;&amp; (<span class="built_in">window</span>.$ = Zepto)</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Zepto </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Zepto </tag>
            
            <tag> 移动端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[单行居中显示文字，多行居左显示，最多两行超过用省略号结尾]]></title>
      <url>/year/10/09/%E9%A6%96%E5%85%88%E6%98%AF%E5%8D%95%E8%A1%8C%E5%B1%85%E4%B8%AD%EF%BC%8C%E5%A4%9A%E8%A1%8C%E5%B1%85%E5%B7%A6/</url>
      <content type="html"><![CDATA[<p>使用纯 CSS，完成单行文本居中显示文字，多行居左显示，最多两行超过用省略号结尾，效果如下：<br>不愿看长篇大论的可以先看看效果：<a href="https://codepen.io/jiangxiaolin1995/pen/qmYzdL" target="_blank" rel="external">-webkit- 内核下 Demo 戳我</a><br><a id="more"></a><br><img src="http://i2.muimg.com/594295/d0dceed9b6341400.png" alt="多行显示"><br>接下来就一步一步来实现这个效果。</p>
<h5 id="首先是单行居中，多行居左"><a href="#首先是单行居中，多行居左" class="headerlink" title="首先是单行居中，多行居左"></a>首先是单行居中，多行居左</h5><p>居中需要用到 <code>text-align:center</code>，居左是默认值也就是<code>text-align:left</code>。如合让两者结合起来达到单行居中，多行居左呢？这就需要多一个标签，假设一开始我们定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;h2&gt;单行居中，多行居左&lt;/h2&gt;</div></pre></td></tr></table></figure>
<p>现在，我们在 <code>h2</code> 中间，嵌套多一层标签 p：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;h2&gt;&lt;p&gt;单行居中，多行居左&lt;/p&gt;&lt;/h2&gt;</div></pre></td></tr></table></figure>
<p>我们让内层 p 居左 text-align:left，外层 h2 居中 text-align:center，并且将 p 设置为 display:inline-block ，利用 inline-block 元素可以被父级 text-align:center 居中的特性，这样就可以实现单行居中，多行居左，CSS 如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">p</span> &#123;</div><div class="line">    <span class="attribute">display</span>: inline-block;</div><div class="line">    <span class="attribute">text-align</span>: left;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">h2</span>&#123;</div><div class="line">    <span class="attribute">text-align</span>: center;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>得到的效果如下：<br><img src="http://i2.muimg.com/594295/5519fcaeada1dc34.png" alt="Markdown"></p>
<h5 id="超出两行省略"><a href="#超出两行省略" class="headerlink" title="超出两行省略"></a>超出两行省略</h5><p>完成了第一步，接下来要实现的是超出两行显示省略符号。<br>多行省略是有专门的新 CSS 属性可以实现的，但是有些兼容性不大好。主要用到如下几个：</p>
<ul>
<li><code>display: -webkit-box;</code> // 设置display，将对象作为弹性伸缩盒子模型显示</li>
<li><code>webkit-line-clamp: 2;</code> // 限制在一个块元素显示的文本的行数</li>
<li><code>webkit-box-orient: vertical;</code> // 规定框的子元素应该被水平或垂直排列<br>上述 3 条样式配合 <code>overflow : hidden</code> 和 <code>text-overflow: ellipsis</code> 即可实现 <code>webkit</code> 内核下的多行省略。好，我们将上述说的一共 5 条样式添加给 p 元素<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">p</span> &#123;</div><div class="line">    <span class="attribute">display</span>: inline-block;</div><div class="line">    <span class="attribute">text-align</span>: left;</div><div class="line">    <span class="attribute">overflow </span>: hidden;</div><div class="line">    <span class="attribute">text-overflow</span>: ellipsis;</div><div class="line">    <span class="attribute">display</span>: -webkit-box;</div><div class="line">    <span class="attribute">-webkit-line-clamp</span>: <span class="number">2</span>;</div><div class="line">    <span class="attribute">-webkit-box-orient</span>: vertical;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">h2</span>&#123;</div><div class="line">    <span class="attribute">text-align</span>: center;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>看看效果如下：<br><img src="http://i2.muimg.com/594295/47610dc1f7901281.png" alt="Markdown"><br>（在 -webkit- 内核浏览器下）发现，虽然超出两行的是被省略了，但是第一行也变回了居左，而没有居中。</p>
<p>看回上面的 CSS 中的 p 元素，原因在于我们第一个设置的 <code>display: inline-block</code> ，被接下来设置的 <code>display: -webkit-box</code> 给覆盖掉了，所以不再是 <code>inline-block</code> 特性的内部 p 元素占据了一整行，也就自然而然的不再居中，而变成了正常的居左展示。</p>
<p>记得上面我们解决单行居中，多行居左时的方法吗？上面我们添加多了一层标签解决了问题，这里我们再添加多一层标签，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;h2&gt;&lt;p&gt;&lt;em&gt;单行居中，多行居左&lt;em&gt;&lt;/p&gt;&lt;/h2&gt;</div></pre></td></tr></table></figure>
<p>这里，我们再添加一层 <code>em</code> 标签，接下来，</p>
<ul>
<li>设置 <code>em</code> 为 <code>display: -webkit-box</code></li>
<li>设置 <code>p</code> 为 <code>inline-block</code></li>
<li>设置 <code>h2</code> 为 <code>text-align: center</code><br>嘿！通过再设置多一层标签，解决 <code>display</code> 的问题，完美解决问题，再看看效果：<br><img src="http://i2.muimg.com/594295/d0dceed9b6341400.png" alt="Markdown"><br><a href="https://codepen.io/jiangxiaolin1995/pen/GmGVqW" target="_blank" rel="external">-webkit- 内核下 Demo 戳我</a><br>####法二: 绝对定位障眼法</li>
</ul>
<p>是的，还有第二种方法……</p>
<p>上面我们为了让第一行居中，使用了三层嵌套标签。</p>
<p>这次我们换一种思路，只使用两层标签，但是我们加多一行。结构如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;div class="container"&gt;</div><div class="line">    &lt;h2&gt;</div><div class="line">        &lt;p&gt;我是单行标题居中&lt;/p&gt;</div><div class="line">        &lt;p class="pesudo"&gt;我是单行标题居中&lt;/p&gt;</div><div class="line">    &lt;/h2&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>这里，新添加了一行 <code>class</code> 为 <code>pesudo</code> 的 <code>p</code> 标签，标签内容与文本内容一致，但是我们限定死 <code>class=&quot;pesudo&quot;</code> 的 <code>p</code> 标签高度 <code>height</code> 与上面的 <code>p</code> 的行高 <code>line-height</code>一致，并设置 <code>overflow:hidden</code> ，那么这个 <code>p</code> 标签最多只能能展示出一行文本，接下来使用绝对定位，定位到 <code>h2</code> 的顶部，再设置 <code>text-align:center</code> 以及背景色与 <code>h2</code> 背景色一致。</p>
<p>这样最多显示单行且样式为居中的 <code>class=&quot;pesudo&quot;</code> <code>p</code> 标签就重叠到了原本的 <code>p</code> 标签之上。表现为单行居中，多行时第一行则铺满，解决了我们的问题。多行省略与方法一相同。CSS 如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">h2</span>&#123;</div><div class="line">    <span class="attribute">position</span>:relative;</div><div class="line">    <span class="attribute">line-height</span>:<span class="number">30px</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">p</span>&#123;</div><div class="line">    <span class="attribute">overflow </span>: hidden;</div><div class="line">    <span class="attribute">text-overflow</span>: ellipsis;</div><div class="line">    <span class="attribute">display</span>: -webkit-box;</div><div class="line">    <span class="attribute">-webkit-line-clamp</span>: <span class="number">2</span>;</div><div class="line">    <span class="attribute">-webkit-box-orient</span>: vertical;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.pesudo</span>&#123;</div><div class="line">    <span class="attribute">position</span>:absolute;</div><div class="line">    <span class="attribute">width</span>:<span class="number">100%</span>;</div><div class="line">    <span class="attribute">height</span>:<span class="number">30px</span>;</div><div class="line">    <span class="attribute">overflow</span>:hidden;</div><div class="line">    <span class="attribute">top</span>:<span class="number">0</span>;</div><div class="line">    <span class="attribute">background</span>:<span class="number">#ddd</span>;</div><div class="line">    <span class="attribute">text-align</span>:center;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><a href="https://codepen.io/jiangxiaolin1995/pen/GmGVjW" target="_blank" rel="external">-webkit- 内核下 Demo 戳我</a></p>
<blockquote>
<p>灵感全来于一个<strong>github</strong>项目，不是为了让大家用生僻的<strong>CSS</strong>属性解决需求，在项目中法一完全够用，就是为了大家熟悉<strong>CSS</strong>属性。<br><a href="https://github.com/chokcoco/iCSS" target="_blank" rel="external">github项目地址</a>（感谢<strong>chococo</strong>为维护这个项目付出的努力）</p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[层叠顺序与堆栈上下文]]></title>
      <url>/year/10/09/%E5%B1%82%E5%8F%A0%E9%A1%BA%E5%BA%8F%E4%B8%8E%E5%A0%86%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
      <content type="html"><![CDATA[<h3 id="层叠顺序（stacking-level）与堆栈上下文（stacking-context）知多少？"><a href="#层叠顺序（stacking-level）与堆栈上下文（stacking-context）知多少？" class="headerlink" title="层叠顺序（stacking level）与堆栈上下文（stacking context）知多少？"></a>层叠顺序（stacking level）与堆栈上下文（stacking context）知多少？</h3><p><code>z-index</code> 看上去其实很简单，根据 <code>z-index</code> 的高低决定层叠的优先级，实则深入进去，会发现内有乾坤。<br><a id="more"></a><br>看看下面这个，定义两个 div A 和 B，被包括在同一个父 div 标签下。HTML结构如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;div class="container"&gt;</div><div class="line">    &lt;div class="inline-block"&gt;#divA display:inline-block&lt;/div&gt;</div><div class="line">    &lt;div class="float"&gt; #divB float:left&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>它们的 <strong>CSS</strong> 定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">.container&#123;</div><div class="line">    position:relative;</div><div class="line">    background:#ddd;</div><div class="line">&#125;</div><div class="line">.container &gt; div&#123;</div><div class="line">    width:200px;</div><div class="line">    height:200px;</div><div class="line">&#125;</div><div class="line">.float&#123;</div><div class="line">    float:left;</div><div class="line">    background-color:deeppink;</div><div class="line">&#125;</div><div class="line">.inline-block&#123;</div><div class="line">    display:inline-block;</div><div class="line">    background-color:yellowgreen;</div><div class="line">    margin-left:-100px;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>大概描述起来，意思就是拥有共同父容器的两个 <strong>DIV</strong> 重叠在一起，是 d<code>isplay:inline-block</code> 叠在上面，还是 float:left 叠在上面？</p>
<p>注意这里 <strong>DOM</strong> 的顺序，是先生成 <code>display:inline-block</code> ，再生成 <code>float:left</code> 。当然也可以把两个的 <strong>DOM</strong> 顺序调转如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;div class="container"&gt;</div><div class="line">    &lt;div class="float"&gt; #divB float:left&lt;/div&gt;</div><div class="line">    &lt;div class="inline-block"&gt;#divA display:inline-block&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>会发现，无论顺序如何，始终是 <code>display:inline-block</code> 的 <code>div</code> 叠在上方。</p>
<p><a href="https://codepen.io/jiangxiaolin1995/pen/qmYzdL" target="_blank" rel="external">Demo戳我</a></p>
<p>这里其实是涉及了所谓的层叠水平（stacking level)，有一张图可以很好的诠释：</p>
<p><img src="http://i4.buimg.com/594295/dea868a92d44f1cf.png" alt="层叠顺序"></p>
<p>运用上图的逻辑，上面的题目就迎刃而解，<code>inline-blcok</code> 的 <strong>stacking level</strong> 比之 <code>float</code> 要高，所以无论 <code>DOM</code> 的先后顺序都堆叠在上面。</p>
<p>不过上面图示的说法有一些不准确，按照 <a href="https://www.w3.org/TR/CSS2/visuren.html#propdef-z-index" target="_blank" rel="external">W3官方</a> 的说法，准确的 7 层为：</p>
<ol>
<li><p>the background and borders of the element forming the stacking context.</p>
</li>
<li><p>the child stacking contexts with negative stack levels (most negative first).</p>
</li>
<li><p>the in-flow, non-inline-level, non-positioned descendants.</p>
</li>
<li><p>the non-positioned floats.</p>
</li>
<li><p>the in-flow, inline-level, non-positioned descendants, including inline tables and inline blocks.</p>
</li>
<li><p>the child stacking contexts with stack level 0 and the positioned descendants with stack level 0.</p>
</li>
<li><p>the child stacking contexts with positive stack levels (least positive first).</p>
</li>
</ol>
<p>稍微翻译一下：</p>
<ol>
<li><p>形成堆叠上下文环境的元素的背景与边框</p>
</li>
<li><p>拥有负 <code>z-index</code> 的子堆叠上下文元素 （负的越高越堆叠层级越低）</p>
</li>
<li><p>正常流式布局，非 <code>inline-block</code>，无 <code>position</code> 定位（<code>static</code>除外）的子元素</p>
</li>
<li><p>无 <code>position</code> 定位（<code>static</code>除外）的 <code>float</code> 浮动元素</p>
</li>
<li><p>正常流式布局， <code>inline-block</code>元素，无 <code>position</code> 定位（<code>static</code>除外）的子元素（包括 <code>display:table</code> 和 <code>display:inline</code> ）</p>
</li>
<li><p>拥有 <code>z-index:0</code> 的子堆叠上下文元素</p>
</li>
<li><p>拥有正 <code>z-index:</code> 的子堆叠上下文元素（正的越低越堆叠层级越低）</p>
</li>
</ol>
<p>所以我们的两个 div 的比较是基于上面所列出来的 4 和 5 。5 的 <strong>stacking level</strong> 更高，所以叠得更高。</p>
<p>不过！不过！不过！重点来了，请注意，上面的比较是基于两个 div 都没有形成 堆叠上下文 这个为基础的。下面我们修改一下，给两个 div ，增加一个 <code>opacity</code>:<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">.container&#123;</div><div class="line">    position:relative;</div><div class="line">    background:#ddd;</div><div class="line">&#125;</div><div class="line">.container &gt; div&#123;</div><div class="line">    width:200px;</div><div class="line">    height:200px;</div><div class="line">    opacity:0.9; // 注意这里，增加一个 opacity</div><div class="line">&#125;</div><div class="line">.float&#123;</div><div class="line">    float:left;</div><div class="line">    background-color:deeppink;</div><div class="line">&#125;</div><div class="line">.inline-block&#123;</div><div class="line">    display:inline-block;</div><div class="line">    background-color:yellowgreen;</div><div class="line">    margin-left:-100px;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><a href="https://codepen.io/jiangxiaolin1995/pen/bWMPEB" target="_blank" rel="external">Demo戳我</a>。</p>
<p>会看到，<code>inline-block</code> 的 <code>div</code> 不再一定叠在 <code>float</code> 的 <code>div</code> 之上，而是和 <strong>HTML</strong> 代码中 <strong>DOM</strong> 的堆放顺序有关，后添加的 <code>div</code> 会 叠在先添加的 div 之上。</p>
<p>这里的关键点在于，添加的 <code>opacity:0.9</code> 这个让两个 <code>div</code> 都生成了 <strong>stacking context（堆叠上下文）</strong> 的概念。此时，要对两者进行层叠排列，就需要 <code>z-index</code> ，<code>z-index</code> 越高的层叠层级越高。</p>
<p>堆叠上下文是HTML元素的三维概念，这些HTML元素在一条假想的相对于面向（电脑屏幕的）视窗或者网页的用户的 z 轴上延伸，HTML 元素依据其自身属性按照优先级顺序占用层叠上下文的空间。</p>
<p>那么，如何触发一个元素形成 堆叠上下文 ？方法如下，摘自 <a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context" target="_blank" rel="external">MDN</a>：</p>
<ul>
<li>根元素 (HTML),</li>
<li><code>z-index</code> 值不为 “auto”的 绝对/相对定位</li>
<li>一个 <code>z-index</code> 值不为 <code>&quot;auto&quot;</code>的 flex 项目 (flex item)，即：父元素 <code>display: flex|inline-flex</code></li>
<li><code>opacity</code> 属性值小于 <code>1</code> 的元素（参考 the specification for opacity）</li>
<li><code>transform</code> 属性值不为 <code>&quot;none&quot;</code>的元素</li>
<li><code>mix-blend-mode</code> 属性值不为 <code>&quot;normal&quot;</code>的元素</li>
<li><code>filter</code>值不为<code>“none”</code>的元素</li>
<li><code>perspective</code>值不为<code>“none”</code>的元素</li>
<li><code>isolation</code> 属性被设置为 <code>&quot;isolate&quot;</code>的元素</li>
<li><code>position: fixed</code></li>
<li>在 will-change 中指定了任意 CSS 属性，即便你没有直接指定这些属性的值</li>
<li><code>webkit-overflow-scrolling</code> 属性被设置 <code>&quot;touch&quot;</code>的元素<br>所以，上面我们给两个 <code>div</code> 添加 <code>opacity</code> 属性的目的就是为了形成 <strong>stacking context</strong>。也就是说添加 <code>opacity</code> 替换成上面列出来这些属性都是可以达到同样的效果。</li>
</ul>
<p>在层叠上下文中，其子元素同样也按照上面解释的规则进行层叠。 特别值得一提的是，其子元素的 <code>z-index</code> 值只在父级层叠上下文中有意义。意思就是父元素的 <code>z-index</code> 低于父元素另一个同级元素，子元素 <code>z-index</code> 再高也没用。</p>
<p>理解上面的 <code>stacking-level</code> 与 <code>stacking-context</code> 是理解 CSS 的层叠顺序的关键。</p>
<blockquote>
<p>灵感全来于一个<strong>github</strong>项目，不是为了让大家用生僻的<strong>CSS</strong>属性解决需求，在项目中法一完全够用，就是为了大家熟悉<strong>CSS</strong>属性。<br><a href="https://github.com/chokcoco/iCSS" target="_blank" rel="external">github项目地址</a>（感谢<strong>chococo</strong>为维护这个项目付出的努力）</p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> CSS </tag>
            
            <tag> 边框 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSS斜纹边框效果]]></title>
      <url>/year/10/05/css%E6%96%9C%E7%BA%B9%E8%BE%B9%E6%A1%86/</url>
      <content type="html"><![CDATA[<h4 id="类似下面这个图形，只使用一个标签，可以有多少种实现方式："><a href="#类似下面这个图形，只使用一个标签，可以有多少种实现方式：" class="headerlink" title="类似下面这个图形，只使用一个标签，可以有多少种实现方式："></a>类似下面这个图形，只使用一个标签，可以有多少种实现方式：</h4><p><img src="http://i2.muimg.com/594295/5d62d561e355b363.png" alt="斜纹"><br><a id="more"></a><br>假设我们的单标签为 div:<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>定义如下通用 CSS:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">div</span>&#123;</div><div class="line">    <span class="attribute">position</span>:relative;</div><div class="line">    <span class="attribute">width</span>: <span class="number">180px</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">180px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这一题主要考查的是盒子模型 <strong>Box Model</strong> 与 背景 <strong>background</strong> 的关系，以及使用 <code>background-clip</code> 改变背景的填充方式。</p>
<p><strong>background</strong> 在 <strong>Box Model</strong> 中，他是布满整个元素的盒子区域的，并不是从 <code>padding</code> 内部开始（也就是说从 <code>border</code> 就开始啦），只不过实线边框（solid）部分遮住了部分 <strong>background</strong> ，所以我们使用虚线边框（<code>dashed</code>）就可以看到背景色是从 <code>border</code> 内部开始的。</p>
<p>我们给 div 添加如下样式：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">div</span>&#123;</div><div class="line">    <span class="attribute">background</span>:<span class="number">#9c27b0</span>;</div><div class="line">    <span class="attribute">border</span>:<span class="number">20px</span> dashed <span class="number">#2196f3</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结果如下：<br><img src="http://i2.muimg.com/594295/7c46ad85e59bf5a9.png" alt="backgroundClip"></p>
<p>但有一点需要注意，<code>background-color</code> 是从元素的边框左上角起到右下角止，而 <code>background-image</code> 却不一样，他是从 <code>padding</code> 边缘的左上角起而到 <code>border</code> 的右下角边缘止。</p>
<p><code>background image</code> 的绘制中有两个因素决定了绘图区域：</p>
<ul>
<li><a href="https://drafts.csswg.org/css-backgrounds-3/#background-positioning-area" target="_blank" rel="external">background positioning area</a>。<code>background-origin</code> 属性决定了这个相对定位位置，默认为 <code>padding-box</code>。所以默认的背景图片绘制是从 <code>padding box</code> 的左上顶点开始的。</li>
<li><a href="https://drafts.csswg.org/css-backgrounds-3/#background-painting-area" target="_blank" rel="external">background painting area</a>。<code>background-clip</code> 属性决定了绘制区间，默认为 <code>border-box</code>。所以在 <code>background-repeat: repeat</code> 的情况下：<blockquote>
<p>The image is repeated in this direction as often as needed to cover the background painting area.</p>
</blockquote>
</li>
</ul>
<p>嗯，什么意思呢，你可以戳进这个 <a href="https://codepen.io/jiangxiaolin1995/pen/pPVmYe" target="_blank" rel="external">demo</a> 看看，正常情况下的背景图填充如下：</p>
<p><img src="http://i1.piimg.com/594295/65f76f0cacdaac09.png" alt="backgroundClip咖啡猫"></p>
<p>当然，这个填充规则是可以通过 <code>background-clip</code> 改变的。</p>
<p><code>background-clip</code> 设置元素的背景（背景图片或颜色）是否延伸到边框下面。<br>语法：</p>
<ul>
<li><code>background-clip: border-box;</code>  // 背景延伸到边框外沿（但是在边框之下）</li>
<li><code>background-clip: padding-box;</code> // 边框下面没有背景，即背景延伸到内边距外沿。</li>
<li><code>background-clip: content-box;</code> // 背景裁剪到内容区 (<code>content-box</code>) 外沿。<br>继续，接下来，只需要将中间部分填充为白色即可，这个用伪元素可以轻松完成，所以，其中一个方法如下：<h3 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">div</span>&#123;</div><div class="line">    <span class="attribute">background</span>:<span class="number">#9c27b0</span>;</div><div class="line">    <span class="attribute">border</span>:<span class="number">20px</span> dashed <span class="number">#2196f3</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">div</span><span class="selector-pseudo">::after</span>&#123;</div><div class="line">    <span class="attribute">content</span>:<span class="string">""</span>;</div><div class="line">    <span class="attribute">position</span>:absolute;</div><div class="line">    <span class="attribute">top</span>:<span class="number">0</span>;</div><div class="line">    <span class="attribute">left</span>:<span class="number">0</span>;</div><div class="line">    <span class="attribute">bottom</span>:<span class="number">0</span>;</div><div class="line">    <span class="attribute">right</span>:<span class="number">0</span>;</div><div class="line">    <span class="attribute">background</span>:<span class="number">#fff</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="法二："><a href="#法二：" class="headerlink" title="法二："></a>法二：</h4><p>上面的方法，我们使用了 <code>div</code> 的背景色默认情况下从 border 开始填充，及伪元素设置白色背景色填充 <code>div</code> 的中间的 <code>padding-box</code> 区域完成图形。</p>
<p>也可以反过来，使用伪元素背景色从 border-box 开始填充，使用 div 的背景色填充中间 <code>padding-box</code>区域。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">div</span>&#123;</div><div class="line">    <span class="attribute">background</span>:<span class="number">#fff</span>;</div><div class="line">    <span class="attribute">background-clip</span>:padding-box;</div><div class="line">    <span class="attribute">border</span>:<span class="number">20px</span> dashed <span class="number">#cccc99</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">div</span><span class="selector-pseudo">::before</span>&#123;</div><div class="line">    <span class="attribute">content</span>:<span class="string">""</span>;</div><div class="line">    <span class="attribute">position</span>:absolute;</div><div class="line">    <span class="attribute">top</span>:-<span class="number">20px</span>;</div><div class="line">    <span class="attribute">left</span>:-<span class="number">20px</span>;</div><div class="line">    <span class="attribute">bottom</span>:-<span class="number">20px</span>;</div><div class="line">    <span class="attribute">right</span>:-<span class="number">20px</span>;</div><div class="line">    <span class="attribute">background</span>:<span class="number">#996699</span>;</div><div class="line">    <span class="attribute">z-index</span>:-<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>具体的 <a href="https://codepen.io/jiangxiaolin1995/pen/wdjbLM" target="_blank" rel="external">Demo</a> 戳这里 。</p>
<p>上面 <code>法二</code> 除了用到了 <code>background-clip</code> 改变背景的填充区域，还用到了 <code>z-index</code> 触发元素生成了堆叠上下文（stacking context），改变了元素的层叠顺序（stacking levle），让伪元素背景色叠到了 <code>div</code> 背景色 之下，这两个概念下题会提及。</p>
<blockquote>
<p>主要是想讨论一下 CSS 的盒子模型 Box Model 与 背景 background 的关系，其实本题就是在于一个 dashed 边框，内部使用颜色填充即可，与上面第一题异曲同工，使用阴影、渐变都可以完成，感兴趣可以自己尝试一下其他解法。</p>
<p>灵感全来于一个<strong>github</strong>项目，不是为了让大家用生僻的<strong>CSS</strong>属性解决需求，在项目中法一完全够用，就是为了大家熟悉<strong>CSS</strong>属性。<br><a href="https://github.com/chokcoco/iCSS" target="_blank" rel="external">github项目地址</a>（感谢<strong>chococo</strong>为维护这个项目付出的努力）</p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> CSS </tag>
            
            <tag> 边框 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSS边框效果]]></title>
      <url>/year/10/05/css%E8%BE%B9%E6%A1%86%E6%95%88%E6%9E%9C/</url>
      <content type="html"><![CDATA[<h4 id="下面这个图形，只使用一个标签，可以有多少种实现方式："><a href="#下面这个图形，只使用一个标签，可以有多少种实现方式：" class="headerlink" title="下面这个图形，只使用一个标签，可以有多少种实现方式："></a>下面这个图形，只使用一个标签，可以有多少种实现方式：</h4><p><img src="http://i2.muimg.com/594295/46a3597155715c79.png" alt="enter image description here"><br><a id="more"></a><br>假设我们的单标签是一个 div:<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>定义如下通用CSS：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">div</span>&#123;</div><div class="line">    <span class="attribute">position</span>:relative;</div><div class="line">    <span class="attribute">width</span>:<span class="number">200px</span>;</div><div class="line">    <span class="attribute">height</span>:<span class="number">60px</span>;</div><div class="line">    <span class="attribute">background</span>:<span class="number">#ddd</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="法一：border"><a href="#法一：border" class="headerlink" title="法一：border"></a>法一：border</h5><p>这个应该是最最最容易想到的了<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">div</span>&#123;</div><div class="line">    <span class="attribute">border-left</span>:<span class="number">5px</span> solid deeppink;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="法二：使用伪元素"><a href="#法二：使用伪元素" class="headerlink" title="法二：使用伪元素"></a>法二：使用伪元素</h5><p>一个标签，算上 <code>before</code> 与 <code>after</code> 伪元素，其实算是有三个标签，这也是很多单标签作图的基础，这个效果可以使用伪元素可以轻易完成。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">div</span><span class="selector-pseudo">::after</span>&#123;</div><div class="line">    <span class="attribute">content</span>:<span class="string">""</span>;</div><div class="line">    <span class="attribute">width</span>:<span class="number">5px</span>;</div><div class="line">    <span class="attribute">height</span>:<span class="number">60px</span>;</div><div class="line">    <span class="attribute">position</span>:absolute;</div><div class="line">    <span class="attribute">top</span>:<span class="number">0</span>;</div><div class="line">    <span class="attribute">left</span>:<span class="number">0</span>;</div><div class="line">    <span class="attribute">background</span>:deeppink;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="法三：外-box-shadow"><a href="#法三：外-box-shadow" class="headerlink" title="法三：外 box-shadow"></a>法三：外 <code>box-shadow</code></h5><p>盒阴影 <code>box-shadow</code> 大部分人都只是用了生成阴影，其实阴影可以有多重阴影，阴影不可以不虚化，这就需要去了解一下 <code>box-shaodw</code> 的每一个参数具体作用。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">div</span>&#123;</div><div class="line">    <span class="attribute">box-shadow</span>:-<span class="number">5px</span> <span class="number">0px</span> <span class="number">0</span> <span class="number">0</span> deeppink;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="法四：内-box-shadow"><a href="#法四：内-box-shadow" class="headerlink" title="法四：内 box-shadow"></a>法四：内 <code>box-shadow</code></h5><p>盒阴影还有一个参数 <code>inset</code> ，用于设置内阴影，也可以完成：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">div</span>&#123;</div><div class="line">    <span class="attribute">box-shadow</span>:inset <span class="number">5px</span> <span class="number">0px</span> <span class="number">0</span> <span class="number">0</span> deeppink;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="法五：drop-shadow"><a href="#法五：drop-shadow" class="headerlink" title="法五：drop-shadow"></a>法五：<code>drop-shadow</code></h5><p><code>drop-shadow</code> 是 <strong>CSS3</strong> 新增滤镜 <code>filter</code> 中的其中一个滤镜，也可以生成阴影，不过它的数值参数个数只有 3 个，比之 <code>box-shadow</code> 少一个。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">div</span>&#123;</div><div class="line">    <span class="attribute">filter</span>:<span class="built_in">drop-shadow</span>(-5px 0 0 deeppink);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="法六：渐变-linearGradient"><a href="#法六：渐变-linearGradient" class="headerlink" title="法六：渐变 linearGradient"></a>法六：渐变 <code>linearGradient</code></h5><p>灵活使用 <strong>CSS3</strong> 的渐变可以完成大量想不到的图形，<strong>CSS3</strong> 的渐变分为线性渐变和径向渐变，本题使用线性渐变，可以轻易解题：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">div</span>&#123;</div><div class="line">    <span class="attribute">background-image</span>:<span class="built_in">linear-gradient</span>(90deg, deeppink 0px, deeppink 5px, transparent 5px);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="法七：轮廓-outline"><a href="#法七：轮廓-outline" class="headerlink" title="法七：轮廓 outline"></a>法七：轮廓 <code>outline</code></h5><p>这个用的比较少，<code>outline</code> （轮廓）是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用。这个方法算是下下之选。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">div</span>&#123;</div><div class="line">    <span class="attribute">height</span>:<span class="number">50px</span>;</div><div class="line">    <span class="attribute">outline</span>:<span class="number">5px</span> solid deeppink;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">div</span>&#123;</div><div class="line">    <span class="attribute">position</span>:absolute;</div><div class="line">    <span class="attribute">content</span>:<span class="string">""</span>;</div><div class="line">    <span class="attribute">top</span>:-<span class="number">5px</span>;</div><div class="line">    <span class="attribute">bottom</span>:-<span class="number">5px</span>;</div><div class="line">    <span class="attribute">right</span>:-<span class="number">5px</span>;</div><div class="line">    <span class="attribute">left</span>:<span class="number">0</span>;</div><div class="line">    <span class="attribute">background</span>:<span class="number">#ddd</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="法八-滚动条"><a href="#法八-滚动条" class="headerlink" title="法八: 滚动条"></a>法八: 滚动条</h5><p>这个方法由 小火柴的蓝色理想 提供，通过改变滚动条样式实现：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">div</span>&#123;</div><div class="line">    <span class="attribute">width</span>:<span class="number">205px</span>;</div><div class="line">    <span class="attribute">background</span>:deeppink;</div><div class="line">    <span class="attribute">overflow-y</span>:scroll;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">div</span><span class="selector-pseudo">::-webkit-scrollbar</span>&#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</div><div class="line">    <span class="attribute">background-color</span>:<span class="number">#ddd</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>灵感全来于一个<strong>github</strong>项目，不是为了让大家用生僻的<strong>CSS</strong>属性解决需求，在项目中法一完全够用，就是为了大家熟悉<strong>CSS</strong>属性。<br><a href="https://github.com/chokcoco/iCSS" target="_blank" rel="external">github项目地址</a>（感谢<strong>chococo</strong>为维护这个项目付出的努力）</p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> CSS </tag>
            
            <tag> 边框 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Sass日记]]></title>
      <url>/year/07/15/SCSS%E9%9A%8F%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h1 id="Sass日记"><a href="#Sass日记" class="headerlink" title="Sass日记"></a>Sass日记</h1><p>学习scss做的笔记，比较详细，作为查询手册吧<br><a id="more"></a></p>
<p style="color:green">sass支持css注释</p>

<h3 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h3><h4 id="在sass中"><a href="#在sass中" class="headerlink" title="在sass中"></a>在sass中</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">h1</span></div><div class="line"> <span class="attribute">color</span>:red</div><div class="line"> //缩进两个</div></pre></td></tr></table></figure>
<h4 id="在scss中"><a href="#在scss中" class="headerlink" title="在scss中"></a>在scss中</h4><p>原生css写法<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">h1</span>&#123;</div><div class="line"></div><div class="line"> <span class="attribute">color</span>:red;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="在less中"><a href="#在less中" class="headerlink" title="在less中"></a>在less中</h4><p>支持原生css写法<br><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">h1</span>&#123;</div><div class="line"></div><div class="line"> <span class="attribute">color</span>:red;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="stylus"><a href="#stylus" class="headerlink" title="stylus"></a>stylus</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">h1&#123; <span class="attribute">color</span>:red; &#125;</div><div class="line"><span class="selector-tag">h1</span> <span class="attribute">color</span>:red</div><div class="line"><span class="selector-tag">h1</span> <span class="attribute">color</span> red</div></pre></td></tr></table></figure>
<h3 id="变量的定义"><a href="#变量的定义" class="headerlink" title="变量的定义"></a>变量的定义</h3><h4 id="sass"><a href="#sass" class="headerlink" title="sass"></a>sass</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$color</span>:red</div></pre></td></tr></table></figure>
<h4 id="scss"><a href="#scss" class="headerlink" title="scss"></a>scss</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$color</span>:red;</div></pre></td></tr></table></figure>
<p>less<br><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@color:</span>red;</div></pre></td></tr></table></figure></p>
<p>stylus<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">  $color:red;</div><div class="line">color:red;</div><div class="line">//@尽量不要用@ 容易赋值不上  </div><div class="line">```    </div><div class="line">嵌套</div><div class="line"></div><div class="line">scss</div><div class="line">```scss</div><div class="line">body&#123;</div><div class="line"></div><div class="line"> header&#123;</div><div class="line"></div><div class="line"> &#125;</div><div class="line"></div><div class="line"> selection&#123;</div><div class="line"></div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>函数写法<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">mixin</span> alert(<span class="variable">$color</span>:red)&#123;</div><div class="line"></div><div class="line">     <span class="attribute">color</span>:<span class="variable">$colorl</span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>less<br><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.alert</span>(<span class="variable">@color</span>:blue)&#123;</div><div class="line"></div><div class="line">  <span class="attribute">color</span>:<span class="variable">@color</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>stylus<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">alert($color = blue)&#123;</div><div class="line"></div><div class="line">  color:$color;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>继承</p>
<p>sass与stylus一样<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.block</span>&#123;</div><div class="line"></div><div class="line">      <span class="attribute">margin</span>:<span class="number">10px</span>;</div><div class="line"></div><div class="line">      <span class="attribute">padding</span>:<span class="number">5px</span>;</div><div class="line"></div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="selector-tag">p</span>&#123;</div><div class="line"></div><div class="line">      @<span class="keyword">extend</span> .block;</div><div class="line"></div><div class="line"> &#125;</div><div class="line">less</div><div class="line"></div><div class="line"><span class="selector-class">.block</span>&#123;</div><div class="line"></div><div class="line">  <span class="attribute">margin</span>:<span class="number">10px</span>;</div><div class="line"></div><div class="line">  <span class="attribute">padding</span>:<span class="number">5px</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">p</span>&#123;</div><div class="line"></div><div class="line">   <span class="selector-class">.block</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="sass基础语法"><a href="#sass基础语法" class="headerlink" title="sass基础语法"></a>sass基础语法</h3><h4 id="利用sass创建工程"><a href="#利用sass创建工程" class="headerlink" title="利用sass创建工程"></a>利用sass创建工程</h4><ul>
<li>创建文件夹即可<h4 id="利用compass创建工程"><a href="#利用compass创建工程" class="headerlink" title="利用compass创建工程"></a>利用compass创建工程</h4></li>
</ul>
<ol>
<li>在当前目录地址栏输入<strong>CMD</strong> ，进入当前目录的<strong>CMD</strong>，输入命令 <code>compass creat hello</code><br><img src="http://i1.piimg.com/594295/80746f3074b4526c.png" alt="Alt text"></li>
</ol>
<p><img src="http://i1.piimg.com/594295/e3c3761a380bbe21.png" alt="Alt text"></p>
<p><img src="http://i1.piimg.com/594295/c1678a693c6f3e53.png" alt="Alt text"></p>
<ol>
<li>通过命令<code>compass creat --bare --sass-dir&quot;sass&quot;--css-dir&quot;css&quot;--images-dir&quot;img&quot;--javascript-dir&quot;js&quot;</code> 可以指定相应文件存放的文件 夹</li>
</ol>
<h4 id="使用命令行"><a href="#使用命令行" class="headerlink" title="使用命令行"></a>使用命令行</h4><ol>
<li><p>编译sass</p>
<p> 在scss文件夹下进入<strong>CMD</strong> 输入命令 <code>scss demo1.scss demo1.css</code><br> <img src="http://i1.piimg.com/594295/6e4f055c1686d3f2.png" alt="Alt text"></p>
</li>
</ol>
<ol>
<li>监视sass文件变化 以达到自动编译的目的<br>在SCSS文件夹下进入<strong>CMD</strong> 输入命令 <code>scss --watch demo1.scss:demo1.css</code><br><img src="http://i1.piimg.com/594295/480696598c976e00.png" alt="Alt text"></li>
</ol>
<ol>
<li><p>监视sass文件夹变化 以达到自动编译文件夹的目的<br><img src="http://i1.piimg.com/594295/aff738f58ab26d45.png" alt="Markdown"><br><img src="http://i1.piimg.com/594295/10ef45a816d9a8dd.png" alt="Markdown"><br><img src="http://i1.piimg.com/594295/39164a31b01e3a5d.png" alt="Markdown"></p>
</li>
<li><p>compass编译sass</p>
<p>在<strong>hello</strong>文件夹下输入<strong>CMD</strong> 输入命令 <code>compass compile</code> 文件直接编译在<strong>stylesheets</strong>文件夹中<br><img src="http://i1.piimg.com/594295/e7696c682e0485df.png" alt="Alt text"><br><img src="http://i1.piimg.com/594295/bd1901db4daabc63.png" alt="Markdown"></p>
</li>
</ol>
<p>如果要强制编译所有的<strong>sass</strong>文件则使用<code>compass --force</code> 命令 不管<strong>sass</strong>有没有更新都编译一次</p>
<ol>
<li><p>compass监视sass</p>
<p> 在<strong>hello</strong>文件夹下输入<strong> CMD </strong> 输入命令<code>compass watch</code> 文件夹里的内容直接编译在<strong>stylesheets</strong>文件夹中<br><img src="http://i1.piimg.com/594295/c18f99297ceae8f2.png" alt="Alt text"></p>
</li>
</ol>
<ol>
<li>编译出的css文件风格</li>
</ol>
<p>在<strong>hello</strong>文件夹下输入<strong>CMD</strong> 输入命令 <code>compass watch --force -s compact</code></p>
<h3 id="理解config-rb"><a href="#理解config-rb" class="headerlink" title="理解config.rb"></a>理解config.rb</h3><p><img src="http://i1.piimg.com/594295/3ae13e917f0f0b89.png" alt="Alt text"></p>
<h4 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h4><p><code>environment=:development</code></p>
<p>压缩比例动态设置：<code>output_style = (environment == :development) ? :expanded : :compressed</code><br><img src="http://i1.piimg.com/594295/5edfb9ee7cbfe2e5.png" alt="Alt text"></p>
<h3 id="sass注释"><a href="#sass注释" class="headerlink" title="sass注释"></a>sass注释</h3><ul>
<li><p>//单行注释 不会编译到css文件中</p>
</li>
<li><p>/**/会被编译css文件中</p>
</li>
<li><p>/！ /重要注释 在所有风格中都会保留</p>
</li>
</ul>
<p style="color:red;font-size:22px;">注释中文会出现编码错误</p>

<p>在<strong>ruby</strong>跟目录下<code>C:\Ruby23-x64\lib\ruby\gems\2.3.0\gems\sass-3.4.22\lib\sass找到engine.rb</code>文件</p>
<p>添加<code>Encoding.default_external = Encoding.find(&#39;utf-8&#39;)</code></p>
<p><img src="http://i1.piimg.com/594295/9f11a51b337b96a3.png" alt="Alt text"></p>
<h3 id="sass语法"><a href="#sass语法" class="headerlink" title="sass语法"></a>sass语法</h3><h4 id="sass变量"><a href="#sass变量" class="headerlink" title="sass变量"></a>sass变量</h4><h5 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h5><p>  $变量名</p>
<p><img src="http://i1.piimg.com/594295/856cb574c85cc991.png" alt="Alt text"><br><img src="http://i1.piimg.com/594295/12427ebbd12ab3d9.png" alt="Alt text"></p>
<h5 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h5><p>$变量名：值 !global;<br><img src="http://i1.piimg.com/594295/210672786a7fd30f.png" alt="Alt text"><br><img src="http://i1.piimg.com/594295/03c69edeb02ac06c.png" alt="Markdown"></p>
<h5 id="变量默认值"><a href="#变量默认值" class="headerlink" title="变量默认值"></a>变量默认值</h5><p> 编译器先编译默认值。主要用于部分文件，见下文。<br><img src="http://i1.piimg.com/594295/92211066bacc5dc7.png" alt="Markdown"><br><img src="http://i1.piimg.com/594295/188b8db99d81057c.png" alt="Markdown"></p>
<h5 id="多值变量"><a href="#多值变量" class="headerlink" title="多值变量"></a>多值变量</h5><p><img src="http://i1.piimg.com/594295/adb3a066a2a8ecd9.png" alt="Markdown"><br><img src="http://i1.piimg.com/594295/a01998655adb18ec.png" alt="Markdown"></p>
<h6 id="maps类型"><a href="#maps类型" class="headerlink" title="$maps类型"></a>$maps类型</h6><p><img src="http://i1.piimg.com/594295/43991f2dd28edd14.png" alt="Markdown"><br><img src="http://i1.piimg.com/594295/e0540c193ee0ac17.png" alt="Markdown"></p>
<h5 id="变量的特殊用法"><a href="#变量的特殊用法" class="headerlink" title="变量的特殊用法"></a>变量的特殊用法</h5><p> 变量用在属性或者选择器上，使用 <strong>#{变量名}</strong> 变量可以使用中划线或者下划线 即<code>$text_info=$text-info</code></p>
<p><img src="http://i1.piimg.com/594295/6c76ee7e8661c1e6.png" alt="Markdown">    </p>
<p><img src="http://i1.piimg.com/594295/cbffef68c9315c2a.png" alt="Markdown"></p>
<h3 id="样式导入"><a href="#样式导入" class="headerlink" title="样式导入"></a>样式导入</h3><h4 id="部分文件"><a href="#部分文件" class="headerlink" title="部分文件"></a>部分文件</h4><p>部分文件也是一个sass文件，但是并不需要生产css。根据约定，sass局部文件的文件名以下划线开头。局部文件可 以被多个不同文件引用。当一些样式需要在多个页面甚至多个页面中使用时， 这非常有用。在这中情况下，有时需要在 你的样式表中对导入的样式做一些修改，sass刚好有一个功能解决这个问题，即默认变量值。</p>
<p>以下划线开头的文件sass不会编译。只为导入或者引用做的，不会被编译。<br><img src="http://i1.piimg.com/594295/bd640e841d471a4c.png" alt="Markdown"></p>
<h4 id="嵌套导入"><a href="#嵌套导入" class="headerlink" title="嵌套导入"></a>嵌套导入</h4><h4 id="原生导入"><a href="#原生导入" class="headerlink" title="原生导入"></a>原生导入</h4><p> 因为sass和css都具有@import关键字，并且一模一样，区分：</p>
<ul>
<li><p>被导入文件的名字以.css结尾</p>
</li>
<li><p>被导入文件的名字是一个URL地址（比如 <a href="http://xxx/css.css）" target="_blank" rel="external">http://xxx/css.css）</a></p>
</li>
<li><p>被导入文件的名字是css的URL()值</p>
</li>
</ul>
<p>以上三种情况会被识别为原生css导入 </p>
<p><img src="http://i1.piimg.com/594295/c147fc6ab7db21ba.png" alt="Markdown"><br><img src="http://i1.piimg.com/594295/fba787fb8e706dd6.png" alt="Markdown"></p>
<p> 导入方法</p>
<p><img src="http://i1.piimg.com/594295/1c84d584c4958438.png" alt="Markdown"></p>
<h3 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h3><h4 id="选择器嵌套"><a href="#选择器嵌套" class="headerlink" title="选择器嵌套"></a>选择器嵌套</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.body</span>&#123;</div><div class="line"></div><div class="line"> <span class="selector-tag">header</span>&#123;</div><div class="line"></div><div class="line"> &#125;</div><div class="line"></div><div class="line"> selection&#123;</div><div class="line"></div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>   body下面的<strong>header</strong>和<strong>selection</strong></p>
<h4 id="属性嵌套"><a href="#属性嵌套" class="headerlink" title="属性嵌套"></a>属性嵌套</h4><ul>
<li>只对有中横线样式的属性有效</li>
</ul>
<ul>
<li>对于有中横线的属性<br><img src="http://i1.piimg.com/594295/6cfe6c3d714b21e1.png" alt="Markdown"></li>
</ul>
<h4 id="amp-引用父选择器"><a href="#amp-引用父选择器" class="headerlink" title="&amp;引用父选择器"></a><code>&amp;</code>引用父选择器</h4><p><img src="http://i1.piimg.com/594295/4003cbfdfb136017.png" alt="Markdown"></p>
<p>如果要达到标签的<code>class</code>例如 <code>a.main</code><br><img src="http://i1.piimg.com/594295/efccd7725197cfbe.png" alt="Markdown"></p>
<h4 id="跳出嵌套-at-root"><a href="#跳出嵌套-at-root" class="headerlink" title="跳出嵌套 @at-root"></a>跳出嵌套 @at-root</h4><p>默认 <code>@at-root</code>只会跳出选择器嵌套，而不能跳出<code>@media</code>或 <code>@suppot</code>，如果要跳出这两种，则使用<code>@at-root (without:media)</code>，<code>@at-root (without:suppot)</code>。这个语法关键词有四个：<strong>all</strong>（表示所有），<strong>rule</strong>（表示常规css），<strong>media</strong>（表示media），<strong>support</strong>（表示support因为<code>@support</code>目前还没有广泛使用，所以在此 不详细表述）。我<br>我们默认<code>@at-root</code>其实就是<code>@at-root:without:rule</code>)。</p>
<p><img src="http://i1.piimg.com/594295/58d84f860b53dd21.png" alt="Markdown"><br><img src="http://i1.piimg.com/594295/0fee6a3d2128deb9.png" alt="Markdown"><br><img src="http://i1.piimg.com/594295/a62b054f7fb76f8f.png" alt="Markdown"></p>
<p>默认跳出<strong>media</strong>，但仍然嵌套在<strong>body</strong>中。如下图同时设置两个参数，则可以跳出<strong>body</strong></p>
<p><img src="http://i1.piimg.com/594295/712865ef90e530ce.png" alt="Markdown"></p>
<h4 id="at-root与-amp-组合引用"><a href="#at-root与-amp-组合引用" class="headerlink" title="@at-root与&amp;组合引用"></a><code>@at-root</code>与<code>&amp;</code>组合引用</h4><p><img src="http://i1.piimg.com/594295/ac1a9f78b6b195bc.png" alt="Markdown"></p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="简单继承"><a href="#简单继承" class="headerlink" title="简单继承"></a>简单继承</h4><p><img src="http://i1.piimg.com/594295/21c57af31d789cb6.png" alt="Markdown"></p>
<h4 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h4><p><img src="http://i1.piimg.com/594295/83b45112b71d8bc5.png" alt="Markdown"></p>
<h4 id="链式继承"><a href="#链式继承" class="headerlink" title="链式继承"></a>链式继承</h4><p><img src="http://i1.piimg.com/594295/2ce5d84c35249f23.png" alt="Markdown"></p>
<h4 id="继承的局限性"><a href="#继承的局限性" class="headerlink" title="继承的局限性"></a>继承的局限性</h4><p>如包含选择器<code>.one .two</code>或者相邻兄弟选择器<code>.one+.two</code>不能被继承，又比如如果继承的元素是<strong>a</strong>，恰巧这个<strong>a</strong>元素又有<strong>hover</strong>状态的形式，那么<strong>hover</strong>状态也会被继承</p>
<h4 id="继承交叉合并"><a href="#继承交叉合并" class="headerlink" title="继承交叉合并"></a>继承交叉合并</h4><p><img src="http://i1.piimg.com/594295/622cf6a070ffc7b2.png" alt="Markdown"></p>
<h4 id="继承作用域"><a href="#继承作用域" class="headerlink" title="继承作用域"></a>继承作用域</h4><p><img src="http://i1.piimg.com/594295/77ce822baff8266d.png" alt="Markdown"><br><img src="http://i1.piimg.com/594295/bf3ee68e9f88a7ef.png" alt="Markdown"></p>
<h3 id="占位选择器"><a href="#占位选择器" class="headerlink" title="占位选择器%"></a>占位选择器<code>%</code></h3><p>优势在于：如果不调用则不会有任何多余的css文件，避免了以前在在一些基础文件中定义了很多基础样式，然后在实际应用中不管是否使用了@extend去继承相应的样式，都会解析出多有的样式。占位选择器以%标识定义，通过@extend调用<br><img src="http://i1.piimg.com/594295/d2fec734b8026232.png" alt="Markdown"></p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul>
<li><p>Number</p>
</li>
<li><p>String</p>
</li>
<li><p>List</p>
</li>
<li><p>Map</p>
</li>
<li><p>Color</p>
</li>
<li><p>Boolean</p>
</li>
<li><p>Null<br><img src="http://i1.piimg.com/594295/7e501ea1f13bdf72.png" alt="Markdown"></p>
</li>
</ul>
<h3 id="变量操作"><a href="#变量操作" class="headerlink" title="变量操作"></a>变量操作</h3><ul>
<li>==，！=  所有数字类型都支持</li>
</ul>
<ul>
<li><p>&lt;,&gt;,&lt;=,&gt;=  仅支持数字类型</p>
<ul>
<li>+,-,*,/,%<br><img src="http://i1.piimg.com/594295/26f738e4590cec20.png" alt="Markdown"><br><img src="http://i1.piimg.com/594295/332e7a010e481c75.png" alt="Markdown"><br><img src="http://i1.piimg.com/594295/48a8b59ca5b08fc1.png" alt="Markdown"></li>
</ul>
</li>
</ul>
<ul>
<li>@mixin<br><img src="http://i1.piimg.com/594295/3947b57d5ca3a022.png" alt="Markdown"></li>
</ul>
<ul>
<li>传递多值参数<br><img src="http://i1.piimg.com/594295/cfef01f6e6921981.png" alt="Markdown"></li>
</ul>
<p> 应用于响应式<br><img src="http://i1.piimg.com/594295/c35cf2e8364f4d83.png" alt="Markdown"></p>
<h3 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h3><p>内置函数太多，不一一赘述，只列举常用的几个：</p>
<ul>
<li>rgb()、rgba()<br><img src="http://i1.piimg.com/594295/271f31446b93ff57.png" alt="Markdown"><br><img src="http://i1.piimg.com/594295/e338a32a71c13aa3.png" alt="Markdown"></li>
</ul>
<ul>
<li>lighten()把颜色变浅、darken()把颜色加深</li>
</ul>
<p><img src="http://i1.piimg.com/594295/b937eca3285e1edc.png" alt="Markdown"></p>
<ul>
<li><p>str-length()、str-index<br><img src="http://i1.piimg.com/594295/0e03c50d9a08853f.png" alt="Markdown"></p>
</li>
<li><p>自定义函数<br><img src="http://i1.piimg.com/594295/a310055f3b7cf9b6.png" alt="Markdown"></p>
</li>
</ul>
<ul>
<li>@debug、@warn、@error<br><img src="http://i1.piimg.com/594295/9883fc8d38dc43f6.png" alt="Markdown"><br><img src="http://i1.piimg.com/594295/9b2c7d742d6def7c.png" alt="Markdown"></li>
</ul>
<h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><p><img src="http://i1.piimg.com/594295/b3581d4afc2deaca.png" alt="Markdown"></p>
<h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><p><img src="http://i1.piimg.com/594295/5bde48be35ef56cc.png" alt="Markdown"></p>
<h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><p><img src="http://i1.piimg.com/594295/8495c9163cd29e33.png" alt="Markdown"></p>
<h4 id="each"><a href="#each" class="headerlink" title="each"></a>each</h4><p><img src="http://i1.piimg.com/594295/5f29b1bbb226429d.png" alt="Markdown"></p>
<p>练习的小<a href="http://www.passby.top/Sass-Demo/sass-website/dist/index.html" target="_blank" rel="external">Demo</a></p>
]]></content>
      
        
        <tags>
            
            <tag> Sass </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo配置文件注释]]></title>
      <url>/year/07/08/Next%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%B3%A8%E9%87%8A/</url>
      <content type="html"><![CDATA[<p>NexT配置文件注释，不多说，还是直接上代码。<br><a id="more"></a><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"># Hexo Configuration</div><div class="line">## Docs: https://hexo.io/docs/configuration.html</div><div class="line">## Source: https://github.com/hexojs/hexo/</div><div class="line"></div><div class="line"># Site</div><div class="line">title: passby  #网站名字</div><div class="line">subtitle: 123  #网站副标题</div><div class="line">description: 12313123   #网站描述 表现在侧边栏头像下边</div><div class="line">author: passby  #作者的名字</div><div class="line">language: zh-Hans  #网站使用的语言</div><div class="line">timezone:     #网站时区 默认使用电脑时区</div><div class="line"></div><div class="line"># URL</div><div class="line"># If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'</div><div class="line">#如果您的网站存放在子目录中，例如 http://yoursite.com/blog，则请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。</div><div class="line"></div><div class="line">url: http://yoursite.com</div><div class="line">root: /</div><div class="line">permalink: :year/:month/:day/:title/</div><div class="line">permalink_defaults:</div><div class="line"></div><div class="line"># Directory  目录配置</div><div class="line">source_dir: source  #源文件夹，这个文件夹用来存放内容。</div><div class="line">public_dir: public  #公共文件夹，这个文件夹用于存放生成的站点文件。</div><div class="line">tag_dir: tags  #标签文件夹</div><div class="line">archive_dir: archives  #归档文件夹</div><div class="line">category_dir: categories  #分类文件夹</div><div class="line">code_dir: downloads/code  #nclude code 文件夹</div><div class="line">i18n_dir: :lang  #国际化（i18n）文件夹</div><div class="line">skip_render:  #跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。</div><div class="line"></div><div class="line"># Writing 文章</div><div class="line">new_post_name: :title.md # File name of new posts 新建文章默认文件名</div><div class="line">default_layout: post   # 默认布局</div><div class="line">titlecase: false # Transform title into titlecase 将标题转换为titlecase</div><div class="line">external_link: true # Open external links in new tab 在新标签中打开一个外部链接，默认为true</div><div class="line">filename_case: 0 #转换文件名，1代表小写；2代表大写；默认为0，意思就是创建文章的时候，是否自动帮你转换文件名，默认就行，意义不大。</div><div class="line">render_drafts: false #是否渲染_drafts目录下的文章，默认为false</div><div class="line">post_asset_folder: false  #启动 Asset 文件夹</div><div class="line">relative_link: false   #把链接改为与根目录的相对位址，默认false</div><div class="line">future: true #显示未来的文章，默认false</div><div class="line">highlight: #代码块的设置 </div><div class="line">  enable: true</div><div class="line">  line_number: true</div><div class="line">  auto_detect: false</div><div class="line">  tab_replace:</div><div class="line"></div><div class="line"># Category &amp; Tag 分类和标签的设置</div><div class="line">default_category: uncategorized #默认分类</div><div class="line">category_map:  #分类别名</div><div class="line">tag_map:  #标签别名</div><div class="line"></div><div class="line"># Date / Time format  日期 / 时间 格式</div><div class="line">## Hexo uses Moment.js to parse and display date</div><div class="line">## You can customize the date format as defined in</div><div class="line">## http://momentjs.com/docs/#/displaying/format/</div><div class="line">date_format: YYYY-MM-DD</div><div class="line">time_format: HH:mm:ss</div><div class="line"></div><div class="line"># Pagination 分页</div><div class="line">## Set per_page to 0 to disable pagination  0 = 关闭分页功能</div><div class="line">per_page: 10  #每页显示的文章量</div><div class="line">pagination_dir: page #分页目录</div><div class="line"></div><div class="line"># Extensions  扩展</div><div class="line">## Plugins: https://hexo.io/plugins/</div><div class="line">## Themes: https://hexo.io/themes/</div><div class="line">theme: next #主题名字</div><div class="line">Plugins: hexo-generate-feed  #ree插件</div><div class="line"># Deployment 部署</div><div class="line">## Docs: https://hexo.io/docs/deployment.html</div><div class="line">deploy:</div><div class="line">  type:</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Next </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> NexT </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[NexT主题配置]]></title>
      <url>/year/07/08/Next%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<p>Next是一款简洁优雅且易于使用的主题，配置比较简单，只需要稍微修改配置文件即可，功能也比较全，分类、归档、标签显示明了，让人一看就知道干嘛的。<br><a id="more"></a><br>NexT主题官方文档还算详细，但是有些部分的介绍不够详细，这里我做部分补充，并对自己做了修改的部分作介绍。</p>
<blockquote>
<p>Hexo 有两份主要的配置文件（_config.yml），一份位于站点根目录下，另一份位于主题目录下。为了描述方便，在以下说明中，将前者称为站点配置文件，后者称为主题配置文件。</p>
</blockquote>
<h3 id="NexT主题安装"><a href="#NexT主题安装" class="headerlink" title="NexT主题安装"></a>NexT主题安装</h3><h4 id="下载NexT主题"><a href="#下载NexT主题" class="headerlink" title="下载NexT主题"></a>下载NexT主题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> $ cd your-hexo-site</div><div class="line"> $ git clone https://github.com/iissnan/hexo-theme-next themes/next</div><div class="line">修改站点配置文件</div></pre></td></tr></table></figure>
<h4 id="修改站点配置文件"><a href="#修改站点配置文件" class="headerlink" title="修改站点配置文件"></a>修改站点配置文件</h4><p>修改站点配置文件_config.yml，找到以下部分<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># Extensions</div><div class="line">## Plugins: http://hexo.io/plugins/</div><div class="line">## Themes: http://hexo.io/themes/</div><div class="line">theme: landscape</div></pre></td></tr></table></figure></p>
<p>修改为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># Extensions</div><div class="line">## Plugins: http://hexo.io/plugins/</div><div class="line">## Themes: http://hexo.io/themes/</div><div class="line"># theme: landscape</div><div class="line">theme: next</div></pre></td></tr></table></figure></p>
<p>至此，NexT主题就安装好了，非常方便，在Hexo中切换主题只需修改站点配置文件中theme属性来配置，想换就换。</p>
<h4 id="选择Scheme"><a href="#选择Scheme" class="headerlink" title="选择Scheme"></a>选择Scheme</h4><p>NexT 通过 Scheme 提供主题中的主题。Mist是NexT主题自带的主题，可以通过修改主题配置文件中的scheme属性获得。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># Schemes</div><div class="line">scheme: Mist  #去掉默认的注释即可切换为Mist主题</div></pre></td></tr></table></figure></p>
<h4 id="菜单设置"><a href="#菜单设置" class="headerlink" title="菜单设置"></a>菜单设置</h4><p>NexT主题菜单设置，用于设置博客上方导航栏，在主题配置文件中修改。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">menu:</div><div class="line">  home: /                       #主页</div><div class="line">  categories: /categories	      #分类页（需手动创建）</div><div class="line">  about: /about		              #关于页面（需手动创建）</div><div class="line">  archives: /archives		        #归档页</div><div class="line">  tags: /tags			              #标签页（需手动创建）</div><div class="line">  #commonweal: /404.html        #公益 404 （需手动创建）</div></pre></td></tr></table></figure></p>
<p></p><p style="color:green">只是在menu选项中设置还不能让标签页面、分类页面生效，需要我们手动创建</p><p></p>
<h5 id="标签页面"><a href="#标签页面" class="headerlink" title="标签页面"></a>标签页面</h5><ol>
<li>运行以下命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo new page &quot;tags&quot;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>该命令会在/source目录下会生成一个tags文件夹，里面包含一个index.md文件</p>
<ol>
<li><p>修改/source/tags目录下的index.md文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">title: tags #文章题目</div><div class="line">date: 2015-09-29 14:37:02 #发布日期</div><div class="line">type: &quot;tags&quot; #标签 开启后可以类似标签云的效果</div><div class="line"></div><div class="line">---</div></pre></td></tr></table></figure>
</li>
<li><p>修改主题配置文件<br>去掉tags的注释</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">menu:</div><div class="line">  home: /                       #主页</div><div class="line">  categories: /categories	#分类页（需手动创建）</div><div class="line">  #about: /about		#关于页面（需手动创建）</div><div class="line">  archives: /archives		#归档页</div><div class="line">  tags: /tags			#标签页（需手动创建）</div><div class="line">  #commonweal: /404.html        #公益 404 （需手动创建）</div></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="分类页面"><a href="#分类页面" class="headerlink" title="分类页面"></a>分类页面</h5><ol>
<li>运行以下命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo new page &quot;categories&quot; #创建一个新的文件夹</div></pre></td></tr></table></figure>
</li>
</ol>
<p>该命令会在/source目录下会生成一个categories文件夹，里面包含一个index.md文件</p>
<ol>
<li><p>修改/source/categories目录下的index.md文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">title: categories</div><div class="line">date: 2015-09-29 14:47:21</div><div class="line">type: &quot;categories&quot;</div><div class="line"></div><div class="line">---</div></pre></td></tr></table></figure>
</li>
<li><p>修改主题配置文件<br>去掉categories的注释</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">menu:</div><div class="line">  home: /                       #主页</div><div class="line">  categories: /categories	#分类页（需手动创建）</div><div class="line">  #about: /about		#关于页面（需手动创建）</div><div class="line">  archives: /archives		#归档页</div><div class="line">  tags: /tags			#标签页（需手动创建）</div><div class="line">  #commonweal: /404.html        #公益 404 （需手动创建）</div></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="侧边栏头像设置"><a href="#侧边栏头像设置" class="headerlink" title="侧边栏头像设置"></a>侧边栏头像设置</h5><p>编辑站点配置文件，增加avatar字段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 头像</div><div class="line">avatar: /images/avatar.png</div></pre></td></tr></table></figure></p>
<p>头像图片须放置在主题的/source/images/目录下</p>
<p>这样一个大体的Hexo博客的Next主题已经搭建完成</p>
]]></content>
      
        <categories>
            
            <category> NexT </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> NexT </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo配置文件注释]]></title>
      <url>/year/07/08/Hexo%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%B3%A8%E9%87%8A/</url>
      <content type="html"><![CDATA[<h4 id="Hexo配置文件注释，不多说，直接上代码。"><a href="#Hexo配置文件注释，不多说，直接上代码。" class="headerlink" title="Hexo配置文件注释，不多说，直接上代码。"></a>Hexo配置文件注释，不多说，直接上代码。</h4><a id="more"></a>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"># Hexo Configuration</div><div class="line">## Docs: https://hexo.io/docs/configuration.html</div><div class="line">## Source: https://github.com/hexojs/hexo/</div><div class="line"></div><div class="line"># Site</div><div class="line">title: passby  #网站名字</div><div class="line">subtitle: 123  #网站副标题</div><div class="line">description: 12313123   #网站描述 表现在侧边栏头像下边</div><div class="line">author: passby  #作者的名字</div><div class="line">language: zh-Hans  #网站使用的语言</div><div class="line">timezone:     #网站时区 默认使用电脑时区</div><div class="line"></div><div class="line"># URL</div><div class="line"># If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'</div><div class="line">#如果您的网站存放在子目录中，例如 http://yoursite.com/blog，则请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。</div><div class="line"></div><div class="line">url: http://yoursite.com</div><div class="line">root: /</div><div class="line">permalink: :year/:month/:day/:title/</div><div class="line">permalink_defaults:</div><div class="line"></div><div class="line"># Directory  目录配置</div><div class="line">source_dir: source  #源文件夹，这个文件夹用来存放内容。</div><div class="line">public_dir: public  #公共文件夹，这个文件夹用于存放生成的站点文件。</div><div class="line">tag_dir: tags  #标签文件夹</div><div class="line">archive_dir: archives  #归档文件夹</div><div class="line">category_dir: categories  #分类文件夹</div><div class="line">code_dir: downloads/code  #nclude code 文件夹</div><div class="line">i18n_dir: :lang  #国际化（i18n）文件夹</div><div class="line">skip_render:  #跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。</div><div class="line"></div><div class="line"># Writing 文章</div><div class="line">new_post_name: :title.md # File name of new posts 新建文章默认文件名</div><div class="line">default_layout: post   # 默认布局</div><div class="line">titlecase: false # Transform title into titlecase 将标题转换为titlecase</div><div class="line">external_link: true # Open external links in new tab 在新标签中打开一个外部链接，默认为true</div><div class="line">filename_case: 0 #转换文件名，1代表小写；2代表大写；默认为0，意思就是创建文章的时候，是否自动帮你转换文件名，默认就行，意义不大。</div><div class="line">render_drafts: false #是否渲染_drafts目录下的文章，默认为false</div><div class="line">post_asset_folder: false  #启动 Asset 文件夹</div><div class="line">relative_link: false   #把链接改为与根目录的相对位址，默认false</div><div class="line">future: true #显示未来的文章，默认false</div><div class="line">highlight: #代码块的设置 </div><div class="line">  enable: true</div><div class="line">  line_number: true</div><div class="line">  auto_detect: false</div><div class="line">  tab_replace:</div><div class="line"></div><div class="line"># Category &amp; Tag 分类和标签的设置</div><div class="line">default_category: uncategorized #默认分类</div><div class="line">category_map:  #分类别名</div><div class="line">tag_map:  #标签别名</div><div class="line"></div><div class="line"># Date / Time format  日期 / 时间 格式</div><div class="line">## Hexo uses Moment.js to parse and display date</div><div class="line">## You can customize the date format as defined in</div><div class="line">## http://momentjs.com/docs/#/displaying/format/</div><div class="line">date_format: YYYY-MM-DD</div><div class="line">time_format: HH:mm:ss</div><div class="line"></div><div class="line"># Pagination 分页</div><div class="line">## Set per_page to 0 to disable pagination  0 = 关闭分页功能</div><div class="line">per_page: 10  #每页显示的文章量</div><div class="line">pagination_dir: page #分页目录</div><div class="line"></div><div class="line"># Extensions  扩展</div><div class="line">## Plugins: https://hexo.io/plugins/</div><div class="line">## Themes: https://hexo.io/themes/</div><div class="line">theme: next #主题名字</div><div class="line">Plugins: hexo-generate-feed  #ree插件</div><div class="line"># Deployment 部署</div><div class="line">## Docs: https://hexo.io/docs/deployment.html</div><div class="line">deploy:</div><div class="line">  type:</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Hexo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[123，木头人]]></title>
      <url>/year/07/08/123%EF%BC%8C%E6%9C%A8%E5%A4%B4%E4%BA%BA/</url>
      <content type="html"><![CDATA[<h1 id="博客上线，yeah"><a href="#博客上线，yeah" class="headerlink" title="博客上线，yeah~"></a>博客上线，yeah~</h1><p><strong> 接下来，让我们来玩 ‘123，木头人’吧</strong></p>
<a id="more"></a>
<p>其实也没有什么好说的，平时逛博客的时候偶然发现Hexo，刚好自己也没有博客，于是便萌生了搭建一个博客的想法，在三天的努力下，终于搭成第一版（2016-7-8开始）。</p>
<p>第一眼爱上还要源于NexT主题，在这里感谢一下<a href="iissnan.com">作者</a>,自己以后也会写一些关于Hexo和NexT的坑，不为别的，只是以后还有可能用的到:)<br>自己会写一些关于配置Hexo的文章，方便后人出坑，也会写一些关于NexT配置以及优化的文章，毕竟被他坑过，会翻译一些配置文件的意思以及效果，代码会发布到<a href="https://github.com/jiangxiaolin1995" target="_blank" rel="external">github</a>,尽量在年后发布（如果不出什么意外的话）。</p>
<p>个人信息会在关于页面，以后的网站更新（主要包括功能的添加和样式的改变）都会对应一片博文，方便大家出坑。</p>
<p>以后这个页面会经常更新，毕竟是建博的第一篇文章，经常维护是应该的，博文前端的知识占大部分，偶尔会有别专业知识，目测已经进了前端的坑跳不出来了。</p>
]]></content>
      
        <categories>
            
            <category> 建站 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> start </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
